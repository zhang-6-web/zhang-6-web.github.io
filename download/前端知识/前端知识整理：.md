# 前端知识整理：

### 1.<font style="color:rgba(0, 0, 0, 0.9);background-color:rgb(245, 245, 245);">useMemo 和 useEffect的区别，常用于什么场景下？</font>
<details class="lake-collapse"><summary id="u748002d1"><span class="ne-text">区别</span></summary><p id="u6ffefc44" class="ne-p"><code class="ne-code"><span class="ne-text" style="color: rgba(0, 0, 0, 0.9); font-size: 16px">useMemo</span></code><span class="ne-text" style="color: rgba(0, 0, 0, 0.9); font-size: 16px"> 用于缓存复杂计算的结果，避免在每次渲染时重复计算，依赖值变化时才会重新计算，不触发重新渲染。而 </span><code class="ne-code"><span class="ne-text" style="color: rgba(0, 0, 0, 0.9); font-size: 16px">useEffect</span></code><span class="ne-text" style="color: rgba(0, 0, 0, 0.9); font-size: 16px"> 用于执行副作用（如数据获取、DOM 操作等），在组件渲染后执行，依赖值变化时重新执行，可能会触发重新渲染。简而言之，</span><code class="ne-code"><span class="ne-text" style="color: rgba(0, 0, 0, 0.9); font-size: 16px">useMemo</span></code><span class="ne-text" style="color: rgba(0, 0, 0, 0.9); font-size: 16px"> 优化计算，</span><code class="ne-code"><span class="ne-text" style="color: rgba(0, 0, 0, 0.9); font-size: 16px">useEffect</span></code><span class="ne-text" style="color: rgba(0, 0, 0, 0.9); font-size: 16px"> 处理副作用。</span></p></details>
<details class="lake-collapse"><summary id="ub563cac8"><span class="ne-text">运用场景</span></summary><p id="u51da95e6" class="ne-p"><span class="ne-text">useMemo:</span></p><ol class="ne-ol"><li id="u48a5f75c" data-lake-index-type="0"><strong><span class="ne-text" style="color: rgba(0, 0, 0, 0.9); font-size: 16px">计算复杂数据</span></strong></li><li id="u18ab5a5c" data-lake-index-type="0"><span class="ne-text" style="color: rgba(0, 0, 0, 0.9); font-size: 16px">创建稳定引用</span></li><li id="u976bb31f" data-lake-index-type="0"><span class="ne-text" style="color: rgba(0, 0, 0, 0.9); font-size: 16px">优化渲染性能</span></li></ol><p id="uc7214bf5" class="ne-p"><span class="ne-text" style="color: rgba(0, 0, 0, 0.9); font-size: 16px">useEffect:</span></p><ol class="ne-ol"><li id="u2fb797df" data-lake-index-type="0"><strong><span class="ne-text" style="color: rgba(0, 0, 0, 0.9); font-size: 16px">数据获取</span></strong><span class="ne-text" style="color: rgba(0, 0, 0, 0.9); font-size: 16px">：</span></li><li id="u512d2256" data-lake-index-type="0"><strong><span class="ne-text" style="color: rgba(0, 0, 0, 0.9); font-size: 16px">订阅和取消订阅</span></strong><span class="ne-text" style="color: rgba(0, 0, 0, 0.9); font-size: 16px">：</span></li><li id="uc4ddbd46" data-lake-index-type="0"><strong><span class="ne-text" style="color: rgba(0, 0, 0, 0.9); font-size: 16px">手动更改 DOM</span></strong><span class="ne-text" style="color: rgba(0, 0, 0, 0.9); font-size: 16px">：</span></li><li id="ufd8bdb69" data-lake-index-type="0"><strong><span class="ne-text" style="color: rgba(0, 0, 0, 0.9); font-size: 16px">设置和清除定时器</span></strong><span class="ne-text" style="color: rgba(0, 0, 0, 0.9); font-size: 16px">：</span></li></ol><p id="u848c4c70" class="ne-p"><span class="ne-text" style="color: rgba(0, 0, 0, 0.9); font-size: 16px"></span></p></details>
### 2.如果我定义了：const [tags, setTags] = useState<string[]>([]); 我如何在useMemo 和 useEffect之外获取tags的最新值？
<details class="lake-collapse"><summary id="u758ea6ad"><span class="ne-text" style="font-size: 16px">1.直接访问</span></summary><p id="uf6654916" class="ne-p"><span class="ne-text" style="color: rgba(0, 0, 0, 0.9); font-size: 16px">在组件的主体部分、事件处理函数、自定义钩子等地方，可以直接访问 </span><code class="ne-code"><span class="ne-text" style="color: rgba(0, 0, 0, 0.9); font-size: 16px">tags</span></code><span class="ne-text" style="color: rgba(0, 0, 0, 0.9); font-size: 16px"> 的最新值。这是最简单和最直接的方式。</span></p></details>
<details class="lake-collapse"><summary id="u04e7167c"><span class="ne-text" style="font-size: 16px">2.使用useRef</span></summary><p id="u721b9577" class="ne-p"><span class="ne-text" style="color: rgba(0, 0, 0, 0.9); font-size: 16px">如果你需要在组件的主体部分之外（如异步操作中）访问 </span><code class="ne-code"><span class="ne-text" style="color: rgba(0, 0, 0, 0.9); font-size: 16px">tags</span></code><span class="ne-text" style="color: rgba(0, 0, 0, 0.9); font-size: 16px"> 的最新值，可以使用 </span><code class="ne-code"><span class="ne-text" style="color: rgba(0, 0, 0, 0.9); font-size: 16px">useRef</span></code><span class="ne-text" style="color: rgba(0, 0, 0, 0.9); font-size: 16px"> 来存储 </span><code class="ne-code"><span class="ne-text" style="color: rgba(0, 0, 0, 0.9); font-size: 16px">tags</span></code><span class="ne-text" style="color: rgba(0, 0, 0, 0.9); font-size: 16px"> 的最新值。</span><code class="ne-code"><span class="ne-text" style="color: rgba(0, 0, 0, 0.9); font-size: 16px">useRef</span></code><span class="ne-text" style="color: rgba(0, 0, 0, 0.9); font-size: 16px"> 的值不会像 </span><code class="ne-code"><span class="ne-text" style="color: rgba(0, 0, 0, 0.9); font-size: 16px">useState</span></code><span class="ne-text" style="color: rgba(0, 0, 0, 0.9); font-size: 16px"> 那样触发组件重新渲染，但可以在任何地方访问到最新的值。</span></p></details>
<details class="lake-collapse"><summary id="u9ec96a9a"><span class="ne-text" style="font-size: 16px">3.使用useCallBack</span></summary><p id="u559c52ac" class="ne-p"><span class="ne-text" style="color: rgba(0, 0, 0, 0.9); font-size: 16px">如果你需要在回调函数中访问 </span><code class="ne-code"><span class="ne-text" style="color: rgba(0, 0, 0, 0.9); font-size: 16px">tags</span></code><span class="ne-text" style="color: rgba(0, 0, 0, 0.9); font-size: 16px"> 的最新值，可以使用 </span><code class="ne-code"><span class="ne-text" style="color: rgba(0, 0, 0, 0.9); font-size: 16px">useCallback</span></code><span class="ne-text" style="color: rgba(0, 0, 0, 0.9); font-size: 16px"> 来确保回调函数中访问的是最新的状态。</span></p><p id="u26ff1f27" class="ne-p"><strong><span class="ne-text" style="color: rgba(0, 0, 0, 0.9); font-size: 14px">jsx</span></strong></p><p id="u8af94e4b" class="ne-p"><span class="ne-text" style="color: rgba(0, 0, 0, 0.6); font-size: 14px">复制</span></p><pre data-language="jsx" id="SZk9A" class="ne-codeblock language-jsx"><code>function MyComponent() {
  const [tags, setTags] = useState&lt;string[]&gt;([]);

  const handleAddTag = () =&gt; {
    setTags([...tags, &quot;新标签&quot;]);
  };

  const handleLogTags = useCallback(() =&gt; {
    console.log(&quot;在回调函数中，当前 tags 的值是：&quot;, tags);
  }, [tags]); // 确保 tags 是最新的

  return (
    &lt;div&gt;
      &lt;p&gt;当前标签：{tags.join(&quot;, &quot;)}&lt;/p&gt;
      &lt;button onClick={handleAddTag}&gt;添加标签&lt;/button&gt;
      &lt;button onClick={handleLogTags}&gt;打印标签&lt;/button&gt;
    &lt;/div&gt;
  );
}</code></pre></details>
<details class="lake-collapse"><summary id="ud759138c"><span class="ne-text" style="font-size: 16px">4.使用useReducer</span></summary><p id="u773ea69a" class="ne-p"><span class="ne-text" style="color: rgba(0, 0, 0, 0.9); font-size: 16px">如果你的状态管理更加复杂，可以使用 </span><code class="ne-code"><span class="ne-text" style="color: rgba(0, 0, 0, 0.9); font-size: 16px">useReducer</span></code><span class="ne-text" style="color: rgba(0, 0, 0, 0.9); font-size: 16px"> 来管理 </span><code class="ne-code"><span class="ne-text" style="color: rgba(0, 0, 0, 0.9); font-size: 16px">tags</span></code><span class="ne-text" style="color: rgba(0, 0, 0, 0.9); font-size: 16px">。</span><code class="ne-code"><span class="ne-text" style="color: rgba(0, 0, 0, 0.9); font-size: 16px">useReducer</span></code><span class="ne-text" style="color: rgba(0, 0, 0, 0.9); font-size: 16px"> 提供了更强大的状态管理能力，尤其是在复杂的状态逻辑中。</span></p><p id="ub0fa18b0" class="ne-p"><strong><span class="ne-text" style="color: rgba(0, 0, 0, 0.9); font-size: 14px">jsx</span></strong></p><p id="ue537a4e7" class="ne-p"><span class="ne-text" style="color: rgba(0, 0, 0, 0.6); font-size: 14px">复制</span></p><pre data-language="jsx" id="nluTT" class="ne-codeblock language-jsx"><code>function MyComponent() {
  const [tags, dispatch] = useReducer((state, action) =&gt; {
    switch (action.type) {
      case 'add':
        return [...state, action.payload];
      case 'remove':
        return state.filter((_, index) =&gt; index !== action.payload);
      default:
        return state;
    }
  }, []);

  const handleAddTag = () =&gt; {
    dispatch({ type: 'add', payload: &quot;新标签&quot; });
  };

  const handleLogTags = () =&gt; {
    console.log(&quot;在回调函数中，当前 tags 的值是：&quot;, tags);
  };

  return (
    &lt;div&gt;
      &lt;p&gt;当前标签：{tags.join(&quot;, &quot;)}&lt;/p&gt;
      &lt;button onClick={handleAddTag}&gt;添加标签&lt;/button&gt;
      &lt;button onClick={handleLogTags}&gt;打印标签&lt;/button&gt;
    &lt;/div&gt;
  );
}</code></pre></details>
<details class="lake-collapse"><summary id="uf1c65ac9"><span class="ne-text" style="font-size: 16px">总结</span></summary><ul class="ne-ul"><li id="u0471b137" data-lake-index-type="0"><strong><span class="ne-text" style="color: rgba(0, 0, 0, 0.9); font-size: 16px">直接访问</span></strong><span class="ne-text" style="color: rgba(0, 0, 0, 0.9); font-size: 16px">：最简单和最直接的方式，适用于大多数情况。</span></li><li id="ue8634239" data-lake-index-type="0"><strong><span class="ne-text" style="color: rgba(0, 0, 0, 0.9); font-size: 16px">使用 </span></strong><code class="ne-code"><strong><span class="ne-text" style="color: rgba(0, 0, 0, 0.9); font-size: 16px">useRef</span></strong></code><span class="ne-text" style="color: rgba(0, 0, 0, 0.9); font-size: 16px">：适用于需要在异步操作中访问最新值的场景。</span></li><li id="u3a38c525" data-lake-index-type="0"><strong><span class="ne-text" style="color: rgba(0, 0, 0, 0.9); font-size: 16px">使用 </span></strong><code class="ne-code"><strong><span class="ne-text" style="color: rgba(0, 0, 0, 0.9); font-size: 16px">useCallback</span></strong></code><span class="ne-text" style="color: rgba(0, 0, 0, 0.9); font-size: 16px">：确保回调函数中访问的是最新的状态。</span></li><li id="u32134ea3" data-lake-index-type="0"><strong><span class="ne-text" style="color: rgba(0, 0, 0, 0.9); font-size: 16px">使用 </span></strong><code class="ne-code"><strong><span class="ne-text" style="color: rgba(0, 0, 0, 0.9); font-size: 16px">useMemo</span></strong></code><span class="ne-text" style="color: rgba(0, 0, 0, 0.9); font-size: 16px">：虽然不常见，但也可以用来存储最新的值。</span></li><li id="uf2f8d4be" data-lake-index-type="0"><strong><span class="ne-text" style="color: rgba(0, 0, 0, 0.9); font-size: 16px">使用 </span></strong><code class="ne-code"><strong><span class="ne-text" style="color: rgba(0, 0, 0, 0.9); font-size: 16px">useReducer</span></strong></code><span class="ne-text" style="color: rgba(0, 0, 0, 0.9); font-size: 16px">：适用于复杂的状态管理场景。</span></li></ul></details>


> 更新: 2025-04-29 13:38:36  
> 原文: <https://www.yuque.com/quwaidi-exykz/lv0i4k/ki1ireuh8s3ngw5l>