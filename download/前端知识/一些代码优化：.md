# 一些代码优化：

:::info
看了一下之前写的项目，发现有些文件的代码量异常庞大，于是决定对代码进行优化，暂时的优化主要从以下几个方面：

:::

<details class="lake-collapse"><summary id="ub6017719"><span class="ne-text">html结构抽出成为一个单独的组件</span></summary><p id="u6ee79397" class="ne-p"><span class="ne-text">主要将主文件里面的html结构精简一下，使得代码量减少，一个文件里面的内容不至于过多。</span></p></details>
<details class="lake-collapse"><summary id="ue3e50205"><span class="ne-text">将组件中的纯函数抽出到单独的文件中</span></summary><p id="u6b84be37" class="ne-p"><span class="ne-text">项目中遇到了树组件，对于树的结构的增删改查，一般都是纯函数，比如：</span></p><pre data-language="javascript" id="Me7Tr" class="ne-codeblock language-javascript"><code>// src/utils/tree.ts
import OneMapService from &quot;@/services/oneMapService&quot;;
import { message } from &quot;antd&quot;;
import React from &quot;react&quot;;

// 辅助函数：根据key查找节点
const findNodeByKey = (tree: any, key: string | number): any =&gt; {
  if (!tree) return null;
  if (tree.id === key) {
    return tree;
  }
  if (tree.children) {
    for (const child of tree.children) {
      const found = findNodeByKey(child, key);
      if (found) return found;
    }
  }
  if (tree.relatedObjs) {
    for (const obj of tree.relatedObjs) {
      const found = findNodeByKey(obj, key);
      if (found) return found;
    }
  }
  return null;
};
const updateNodeInTree = (
  tree: any,
  key: string | number,
  updatedNode: any,
  isPublish?: boolean
): any =&gt; {
  if (!tree) return null;
  // 如果是目标节点，直接返回更新后的节点
  if (tree.id === key) {
    if (isPublish) {
    } else {
      return updatedNode;
    }
  }
  // 创建新的树对象
  const newTree = { ...tree };
  // 处理 children
  if (tree.children) {
    newTree.children = tree.children.map((child: any) =&gt;
      updateNodeInTree(child, key, updatedNode)
    );
  }
  if (tree.relatedObjs) {
    newTree.relatedObjs = tree.relatedObjs.map((obj: any) =&gt;
      updateNodeInTree(obj, key, updatedNode)
    );
  }
  return newTree;
};
//执行删除目录或目录节点成功后，更新树形结构
const deleteNodeFromTree = (tree: any, key: string | number): any =&gt; {
  if (!tree) return null;
  // 创建新的树对象
  const newTree = { ...tree };
  // 处理 children
  if (tree.children) {
    // 递归删除 children 中的节点
    newTree.children = tree.children
      .map((child: any) =&gt; {
        // 如果当前节点是要删除的节点，返回 null
        if (child.id === key) {
          return null;
        }
        // 否则递归处理子节点
        return deleteNodeFromTree(child, key);
      })
      .filter((child: any) =&gt; child !== null);
  }
  // 处理 relatedObjs
  if (tree.relatedObjs) {
    // 递归删除 relatedObjs 中的节点
    newTree.relatedObjs = tree.relatedObjs
      .map((obj: any) =&gt; {
        // 如果当前节点是要删除的节点，返回 null
        if (obj.id === key) {
          return null;
        }
        // 否则递归处理子节点
        return deleteNodeFromTree(obj, key);
      })
      .filter((obj: any) =&gt; obj !== null);
  }
  return newTree;
};
// 准备更新后的节点数据
const prepareUpdatedNode = (
  dropNode: any,
  dragNode: any,
  treeWithoutDragNode: any,
  dropKey: string | number
) =&gt; {
  const isRootNode = dropKey === &quot;1&quot;;
  const sourceNode = isRootNode ? treeWithoutDragNode : dropNode;
  if (dragNode.obj) {
    // 叶子节点添加到 relatedObjs
    return {
      ...dropNode,
      children: [...(sourceNode.children || [])],
      relatedObjs: [...(sourceNode.relatedObjs || []), dragNode],
    };
  } else {
    // 目录节点添加到 children
    return {
      ...dropNode,
      children: [...(sourceNode.children || []), dragNode],
      relatedObjs: [...(sourceNode.relatedObjs || [])],
    };
  }
};
// 更新节点数据
const updateNodeData = async (dragNode: any, params: any) =&gt; {
  try {
    let res;
    if (dragNode.obj) {
      // 拖拽的是叶子节点
      res = await OneMapService.updateFoldNode(params);
    } else {
      // 拖拽的是目录节点
      res = await OneMapService.updateFold(
        params.id as string,
        params.catalogId as string,
        dragNode.name as string
      );
    }

    if (res.status !== 200) {
      message.error(res.message);
      return false;
    }
    return true;
  } catch (error) {
    console.error(&quot;API调用失败:&quot;, error);
    message.error(&quot;API调用失败&quot;);
    return false;
  }
};
  /**
   * 判断是否是原始对象即被复制对象
   * @param key id
   * @param data 接口数据-瓦片集数据
   * @returns boolean
   */
  const isPrimary = (key?: string | number, data?: TilesDataItem[]) =&gt; {
    let cur = data?.find((x) =&gt; x.id === key);
    let copydata = data?.filter((x) =&gt; x.refDataSet &amp;&amp; x.refTask);
    // let findPrimary = data?.findIndex((item) =&gt; item.refDataSet === cur?.id);
    let childData = copydata?.filter((item) =&gt; item.refDataSet === cur?.id);
    if (childData &amp;&amp; childData.length &gt; 0) {
      return childData.map((item) =&gt; item.name);
    } else {
      return false;
    }
  };

export { findNodeByKey, updateNodeInTree, deleteNodeFromTree,prepareUpdatedNode, updateNodeData,isPrimary};
</code></pre></details>
<details class="lake-collapse"><summary id="u0fec42f8"><span class="ne-text">在构造树形结构的时候，发现往往都会出现，js和html混在一起的情况</span></summary><p id="u47bf7b9a" class="ne-p"><br></p></details>


> 更新: 2025-06-27 15:41:02  
> 原文: <https://www.yuque.com/quwaidi-exykz/lv0i4k/pg7x8aw2cig9sfqt>