# 大屏无缝轮播实现（整组轮播）

:::info
核心思想：

1. 数据复制：<font style="color:rgba(0, 0, 0, 0.9);">通过复制原始数据，我们创建了一个“虚拟”的数据集，使得在视觉上看起来像是数据是无限循环的。这样，当轮播到最后一组时，我们可以通过跳转到复制的数据的开头，实现无缝过渡。</font>
2. <font style="color:rgba(0, 0, 0, 0.9);">视觉欺骗：</font>
+ 初始状态：显示第一组数据。
+ 切换逻辑：<font style="color:rgba(0, 0, 0, 0.9);">每次切换时，更新 </font>`<font style="color:rgba(0, 0, 0, 0.9);background-color:rgba(0, 0, 0, 0.03);">currentIndex</font>`<font style="color:rgba(0, 0, 0, 0.9);">，并通过 </font>`<font style="color:rgba(0, 0, 0, 0.9);background-color:rgba(0, 0, 0, 0.03);">transform</font>`<font style="color:rgba(0, 0, 0, 0.9);"> 属性移动轮播内容。</font>
+ 瞬间跳转: **<font style="color:rgba(0, 0, 0, 0.9);"> </font>**<font style="color:rgba(0, 0, 0, 0.9);">当到达最后一组时，瞬间跳转到第一组，但通过 </font>`<font style="color:rgba(0, 0, 0, 0.9);background-color:rgba(0, 0, 0, 0.03);">transitionend</font>`<font style="color:rgba(0, 0, 0, 0.9);"> 事件确保动画的平滑性。</font>
3. <font style="color:rgba(0, 0, 0, 0.9);">瞬间跳转的实现：</font>
+ 瞬间跳转：<font style="color:rgba(0, 0, 0, 0.9);">当到达最后一组时，瞬间跳转到第一组。</font>
    - <font style="color:rgba(0, 0, 0, 0.9);">设置 </font>`<font style="color:rgba(0, 0, 0, 0.9);background-color:rgba(0, 0, 0, 0.03);">transform</font>`<font style="color:rgba(0, 0, 0, 0.9);"> 为 </font>`<font style="color:rgba(0, 0, 0, 0.9);background-color:rgba(0, 0, 0, 0.03);">translateX(0%)</font>`<font style="color:rgba(0, 0, 0, 0.9);">，将内容瞬间移动到第一组。</font>
    - <font style="color:rgba(0, 0, 0, 0.9);">通过 </font>`<font style="color:rgba(0, 0, 0, 0.9);background-color:rgba(0, 0, 0, 0.03);">requestAnimationFrame</font>`<font style="color:rgba(0, 0, 0, 0.9);"> 确保动画的平滑性。</font>
+ 恢复动画：<font style="color:rgba(0, 0, 0, 0.9);">在 </font>`<font style="color:rgba(0, 0, 0, 0.9);background-color:rgba(0, 0, 0, 0.03);">transitionend</font>`<font style="color:rgba(0, 0, 0, 0.9);"> 事件中，恢复动画效果。</font>

:::

<details class="lake-collapse"><summary id="uc0a24d1a"><span class="ne-text">左右轮播</span></summary><pre data-language="tsx" id="Lz8mI" class="ne-codeblock language-tsx"><code>import React, { useState, useEffect, useRef } from &quot;react&quot;;
import &quot;./index.css&quot;; // 引入样式文件
interface Props {
  items: any[];
  itemsPerSlide: number;
  interval: number;
}
const Carousel: React.FC&lt;Props&gt; = ({ items, itemsPerSlide, interval }) =&gt; {
  // 1. 分组
  const totalItems = items.length;
  const totalSlides = Math.ceil(totalItems / itemsPerSlide);
  const grouped: any[][] = [];
  for (let i = 0; i &lt; totalSlides; i++) {
    grouped.push(items.slice(i * itemsPerSlide, (i + 1) * itemsPerSlide));
  }
  // 2. 首尾拼接
  const renderList = [
    grouped[grouped.length - 1], // 假最后一组
    ...grouped,
    grouped[0], // 假第一组
  ];
  console.log(&quot;renderList&quot;, renderList);
  const [currentIndex, setCurrentIndex] = useState(1); // 初始为1
  const [isTransitioning, setIsTransitioning] = useState(true);
  const timerRef = useRef&lt;any&gt;(null);
  const slideRef = useRef&lt;HTMLDivElement&gt;(null);
  // 自动播放
  useEffect(() =&gt; {
    timerRef.current = setInterval(() =&gt; {
      setCurrentIndex((prev) =&gt; prev + 1);
      setIsTransitioning(true);
    }, interval);
    return () =&gt; clearInterval(timerRef.current);
  }, [interval, renderList.length]);
  // items变化时重置
  useEffect(() =&gt; {
    setCurrentIndex(1);
    setIsTransitioning(true);
  }, [itemsPerSlide, items]);
  // 监听transitionend实现无缝跳转
  useEffect(() =&gt; {
    const node = slideRef.current;
    if (!node) return;
    const handleTransitionEnd = () =&gt; {
      if (currentIndex === renderList.length - 1) {
        // 到达假第一组，瞬间跳到真第一组
        setIsTransitioning(false);
        setCurrentIndex(1);
      } else if (currentIndex === 0) {
        // 到达假最后一组，瞬间跳到真最后一组
        setIsTransitioning(false);
        setCurrentIndex(renderList.length - 2);
      }
    };
    node.addEventListener(&quot;transitionend&quot;, handleTransitionEnd);
    return () =&gt; node.removeEventListener(&quot;transitionend&quot;, handleTransitionEnd);
  }, [currentIndex, renderList.length]);
  // 处理瞬间跳转时去掉动画
  useEffect(() =&gt; {
    if (!isTransitioning) {
      // 关闭动画，下一帧再恢复
      const id = setTimeout(() =&gt; setIsTransitioning(true), 20);
      return () =&gt; clearTimeout(id);
    }
  }, [isTransitioning]);
  return (
    &lt;div className=&quot;carousel-container&quot;&gt;
      &lt;div
        className=&quot;carousel-slide&quot;
        ref={slideRef}
        style={{
          transform: `translateX(${-currentIndex * 100}%)`,
          transition: isTransitioning ? &quot;transform 0.5s ease-in-out&quot; : &quot;none&quot;,
          display: &quot;flex&quot;,
        }}
      &gt;
        {renderList.map((group, idx) =&gt; (
          &lt;div
            key={idx}
            className=&quot;carousel-group&quot;
            style={{ flex: &quot;0 0 100%&quot;, display: &quot;flex&quot; }}
          &gt;
            {group.map((item, i) =&gt; (
              &lt;div
                key={i}
                className=&quot;carousel-item&quot;
                style={{ flex: `0 0 ${100 / itemsPerSlide}%` }}
              &gt;
                {item}
              &lt;/div&gt;
            ))}
          &lt;/div&gt;
        ))}
      &lt;/div&gt;
    &lt;/div&gt;
  );
};
export default Carousel;</code></pre><pre data-language="css" id="ARRHu" class="ne-codeblock language-css"><code>.carousel-container {
  overflow: hidden;
  width: 100%;
}
.carousel-slide {
  display: flex;
  width: 100%;
}
.carousel-group {
  flex: 0 0 100%;
  display: flex;
}
.carousel-item {
  /* 每屏2项就是50%，3项就是33.33% */
  flex: 0 0 50%;
  box-sizing: border-box;
  padding: 10px;
  text-align: center;
  border: 1px solid #ccc;
  /* margin-right: 10px;  // 如需间距可加 */
}
</code></pre></details>
<details class="lake-collapse"><summary id="uc2c7a2eb"><span class="ne-text">上下轮播</span></summary><pre data-language="css" id="xs15a" class="ne-codeblock language-css"><code>import React, { useState, useEffect, useRef } from &quot;react&quot;;
import &quot;./index.css&quot;; // 引入样式文件
interface Props {
  items: any[];
  itemsPerSlide: number;
  interval: number;
}
const Carousel: React.FC&lt;Props&gt; = ({ items, itemsPerSlide, interval }) =&gt; {
  // 1. 分组
  const totalItems = items.length;
  const totalSlides = Math.ceil(totalItems / itemsPerSlide);
  const grouped: any[][] = [];
  for (let i = 0; i &lt; totalSlides; i++) {
    grouped.push(items.slice(i * itemsPerSlide, (i + 1) * itemsPerSlide));
  }
  // 2. 首尾拼接
  const renderList = [
    grouped[grouped.length - 1], // 假最后一组
    ...grouped,
    grouped[0], // 假第一组
  ];
  const [currentIndex, setCurrentIndex] = useState(1); // 初始为1
  const [isTransitioning, setIsTransitioning] = useState(true);
  const timerRef = useRef&lt;any&gt;(null);
  const slideRef = useRef&lt;HTMLDivElement&gt;(null);

  // 自动播放
  useEffect(() =&gt; {
    timerRef.current = setInterval(() =&gt; {
      setCurrentIndex((prev) =&gt; prev + 1);
      setIsTransitioning(true);
    }, interval);
    return () =&gt; clearInterval(timerRef.current);
  }, [interval, renderList.length]);

  // items变化时重置
  useEffect(() =&gt; {
    setCurrentIndex(1);
    setIsTransitioning(true);
  }, [itemsPerSlide, items]);

  // 监听transitionend实现无缝跳转
  useEffect(() =&gt; {
    const node = slideRef.current;
    if (!node) return;
    const handleTransitionEnd = () =&gt; {
      if (currentIndex === renderList.length - 1) {
        setIsTransitioning(false);
        setCurrentIndex(1);
      } else if (currentIndex === 0) {
        setIsTransitioning(false);
        setCurrentIndex(renderList.length - 2);
      }
    };
    node.addEventListener(&quot;transitionend&quot;, handleTransitionEnd);
    return () =&gt; node.removeEventListener(&quot;transitionend&quot;, handleTransitionEnd);
  }, [currentIndex, renderList.length]);

  // 处理瞬间跳转时去掉动画
  useEffect(() =&gt; {
    if (!isTransitioning) {
      const id = setTimeout(() =&gt; setIsTransitioning(true), 20);
      return () =&gt; clearTimeout(id);
    }
  }, [isTransitioning]);

  return (
    &lt;div className=&quot;carousel-container-vertical&quot;&gt;
      &lt;div
        className=&quot;carousel-slide-vertical&quot;
        ref={slideRef}
        style={{
          transform: `translateY(${-currentIndex * 100}%)`,
          transition: isTransitioning ? &quot;transform 0.5s ease-in-out&quot; : &quot;none&quot;,
          height: `${renderList.length * 100}%`,
        }}
      &gt;
        {renderList.map((group, idx) =&gt; (
          &lt;div
            key={idx}
            className=&quot;carousel-group-vertical&quot;
            // style={{ height: &quot;100%&quot;, display: &quot;flex&quot;, flexDirection: &quot;column&quot; }}
          &gt;
            {group.map((item, i) =&gt; (
              &lt;div
                key={i}
                className=&quot;carousel-item-vertical&quot;
                // style={{ height: `${100 / itemsPerSlide}%` }}
              &gt;
                {item}
              &lt;/div&gt;
            ))}
          &lt;/div&gt;
        ))}
      &lt;/div&gt;
    &lt;/div&gt;
  );
};

export default Carousel;
</code></pre><pre data-language="css" id="thstD" class="ne-codeblock language-css"><code>.carousel-container {
  overflow: hidden;
  width: 100%;
}
.carousel-slide {
  /* display: flex; */
  width: 100%;
}
.carousel-group {
  flex: 0 0 100%;
  display: flex;
}
.carousel-item {
  /* 每屏2项就是50%，3项就是33.33% */
  flex: 0 0 50%;
  box-sizing: border-box;
  padding: 10px;
  text-align: center;
  border: 1px solid #ccc;
  /* margin-right: 10px;  // 如需间距可加 */
}
.carousel-container-vertical {
  overflow: hidden;
  width: 100%;
  height: 80px; /* 可根据需要调整 */
  position: relative;
}
.carousel-slide-vertical {
  width: 100%;
  height: 100%;
}
.carousel-group-vertical {
  width: 100%;
  height: 100%;
  display: flex;
  flex-direction: column;
}
.carousel-item-vertical {
  width: 100%;
  /* 高度由内联样式控制 */
  box-sizing: border-box;
  padding: 10px;
  text-align: center;
  border: 1px solid #ccc;
}</code></pre></details>


> 更新: 2025-07-10 15:52:53  
> 原文: <https://www.yuque.com/quwaidi-exykz/lv0i4k/rt489nxs0f3d4egw>