# 树节点拖拽排序实现

:::info
`<font style="color:rgba(0, 0, 0, 0.9);background-color:rgba(0, 0, 0, 0.03);">onDrop</font>`<font style="color:rgba(0, 0, 0, 0.9);"> 函数是一个异步函数，用于处理树形组件中的节点拖拽事件。它接收一个 </font>`<font style="color:rgba(0, 0, 0, 0.9);background-color:rgba(0, 0, 0, 0.03);">info</font>`<font style="color:rgba(0, 0, 0, 0.9);"> 参数，该参数包含了拖拽操作的相关信息，并执行一系列操作来更新树形结构的数据。</font>

:::

> **树节点拖拽的具体实现流程：**
>
> 1. **<font style="color:rgba(0, 0, 0, 0.9);">获取节点键值</font>**<font style="color:rgba(0, 0, 0, 0.9);">：</font>
>     - `<font style="color:rgba(0, 0, 0, 0.9);background-color:rgba(0, 0, 0, 0.03);">dropKey</font>`<font style="color:rgba(0, 0, 0, 0.9);">: 目标节点的键值。</font>
>     - `<font style="color:rgba(0, 0, 0, 0.9);background-color:rgba(0, 0, 0, 0.03);">dragKey</font>`<font style="color:rgba(0, 0, 0, 0.9);">: 被拖拽节点的键值。</font>
> 2. **<font style="color:rgba(0, 0, 0, 0.9);">更新展开的节点键值</font>**<font style="color:rgba(0, 0, 0, 0.9);">：</font>
>     - <font style="color:rgba(0, 0, 0, 0.9);">使用 </font>`<font style="color:rgba(0, 0, 0, 0.9);background-color:rgba(0, 0, 0, 0.03);">setExpandedKeys</font>`<font style="color:rgba(0, 0, 0, 0.9);"> 更新展开的节点键值，确保目标节点被展开。</font>
> 3. **<font style="color:rgba(0, 0, 0, 0.9);">查找节点</font>**<font style="color:rgba(0, 0, 0, 0.9);">：</font>
>     - <font style="color:rgba(0, 0, 0, 0.9);">使用 </font>`<font style="color:rgba(0, 0, 0, 0.9);background-color:rgba(0, 0, 0, 0.03);">findNodeByKey</font>`<font style="color:rgba(0, 0, 0, 0.9);"> 函数查找拖拽节点和目标节点的具体信息。</font>
> 4. **<font style="color:rgba(0, 0, 0, 0.9);">检查节点是否存在</font>**<font style="color:rgba(0, 0, 0, 0.9);">：</font>
>     - <font style="color:rgba(0, 0, 0, 0.9);">如果拖拽节点或目标节点不存在，则显示错误消息并返回。</font>
> 5. **<font style="color:rgba(0, 0, 0, 0.9);">防止拖拽叶子节点下</font>**<font style="color:rgba(0, 0, 0, 0.9);">：</font>
>     - <font style="color:rgba(0, 0, 0, 0.9);">如果目标节点没有子节点，则直接返回，不允许拖拽。</font>
> 6. **<font style="color:rgba(0, 0, 0, 0.9);">自动展开目录节点</font>**<font style="color:rgba(0, 0, 0, 0.9);">：</font>
>     - <font style="color:rgba(0, 0, 0, 0.9);">如果目标节点未展开，则自动展开该节点，并获取其完整信息。</font>
> 7. **<font style="color:rgba(0, 0, 0, 0.9);">删除原位置的节点</font>**<font style="color:rgba(0, 0, 0, 0.9);">：</font>
>     - <font style="color:rgba(0, 0, 0, 0.9);">使用 </font>`<font style="color:rgba(0, 0, 0, 0.9);background-color:rgba(0, 0, 0, 0.03);">deleteNodeFromTree</font>`<font style="color:rgba(0, 0, 0, 0.9);"> 函数从树中删除被拖拽的节点。</font>
> 8. **<font style="color:rgba(0, 0, 0, 0.9);">更新节点数据</font>**<font style="color:rgba(0, 0, 0, 0.9);">：</font>
>     - <font style="color:rgba(0, 0, 0, 0.9);">准备更新后的节点数据，并调用相应的API更新数据。</font>
> 9. **<font style="color:rgba(0, 0, 0, 0.9);">更新整个树数据</font>**<font style="color:rgba(0, 0, 0, 0.9);">：</font>
>     - <font style="color:rgba(0, 0, 0, 0.9);">使用 </font>`<font style="color:rgba(0, 0, 0, 0.9);background-color:rgba(0, 0, 0, 0.03);">updateNodeInTree</font>`<font style="color:rgba(0, 0, 0, 0.9);"> 函数更新整个树形结构的数据。</font>
>

```javascript
  const onDrop: TreeProps["onDrop"] = async (info) => {
    const dropKey = info.node.key; // 目标节点key
    const dragKey = info.dragNode.key; // 被拖拽节点key
    setExpandedKeys(Array.from(new Set([...expandedKeys, dropKey])));
    const dropNode = findNodeByKey(isNotHandleData, dropKey as any);
    const dragNode = findNodeByKey(isNotHandleData, dragKey as any);
    if (!dropNode || !dragNode) {
      message.error("节点不存在");
      return;
    }
    // // 防止拖拽叶子节点下
    if (!dropNode.children) {
      return;
    }
    // 拖拽至未展开的目录节点下时，自动展开目录节点
    let updatedDropNode = deleteNodeFromTree(dropNode, dragKey as any);
    if (!expandedKeys.includes(dropKey)) {
      try {
        // 获取展开节点的完整信息
        const response = await OneMapService.queryFoldById(dropKey as string);
        if (response.status === 200) {
          setLoadKeys(Array.from(new Set([...loadKeys, dropKey])));
          // 使用获取到的完整节点信息
          updatedDropNode = response.data;
        } else {
          message.error("获取节点信息失败");
          return;
        }
      } catch (error) {
        console.error("获取节点信息失败:", error);
        message.error("获取节点信息失败");
        return;
      }
    }
    const params = {
      id: dragNode.id,
      obj: (dragNode as any).obj,
      catalogId: updatedDropNode.id,
    };
    try {
      // 1. 先删除原位置的节点
      const treeWithoutDragNode = deleteNodeFromTree(
        isNotHandleData,
        dragKey as any
      );
      // 2. 准备更新后的节点数据
      const updatedNode = prepareUpdatedNode(
        updatedDropNode, // 使用更新后的节点信息
        dragNode,
        treeWithoutDragNode,
        dropKey as any
      );
      // 3. 调用相应的API更新数据
      const res = await updateNodeData(dragNode, params);
      if (!res) return;
      // 4. 更新整个树数据
      const newTreeData = updateNodeInTree(
        treeWithoutDragNode,
        updatedDropNode.id as any,
        updatedNode
      );
      setIsNotHandleData(newTreeData);
    } catch (error) {
      console.error("更新失败:", error);
      message.error("更新失败");
    }
  };
```



> 更新: 2025-06-27 17:19:09  
> 原文: <https://www.yuque.com/quwaidi-exykz/lv0i4k/tyad68qpwabgkfyf>