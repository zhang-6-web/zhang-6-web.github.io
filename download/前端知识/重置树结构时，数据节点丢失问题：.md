# 重置树结构时，数据节点丢失问题：

原因：

1. **<font style="color:rgb(216, 222, 233);background-color:rgb(20, 20, 20);">异步懒加载树节点</font>**

<font style="color:rgb(216, 222, 233);background-color:rgb(20, 20, 20);">你的树是异步加载的，只有展开节点时才去请求children并合并到树结构中。</font>

2. **<font style="color:rgb(216, 222, 233);background-color:rgb(20, 20, 20);">直接替换children导致丢失</font>**

<font style="color:rgb(216, 222, 233);background-color:rgb(20, 20, 20);">你在</font>updateTreeData<font style="color:rgb(216, 222, 233);background-color:rgb(20, 20, 20);">时，每次加载children都会</font>**<font style="color:rgb(216, 222, 233);background-color:rgb(20, 20, 20);">直接替换</font>**<font style="color:rgb(216, 222, 233);background-color:rgb(20, 20, 20);">当前节点的children。如果新children不包含原有的children（比如只加载了部分叶子节点），原有的children就会被覆盖丢失。</font>

3. **<font style="color:rgb(216, 222, 233);background-color:rgb(20, 20, 20);">cloneDeep不能解决“数据不全”</font>**

<font style="color:rgb(216, 222, 233);background-color:rgb(20, 20, 20);">你尝试用</font>_.cloneDeep<font style="color:rgb(216, 222, 233);background-color:rgb(20, 20, 20);">断开treeData和originTreeData的引用，但如果原始数据已经丢失，cloneDeep也只是复制了“丢失节点的树”，无法恢复所有已加载过的children。</font>

4. **<font style="color:rgb(216, 222, 233);background-color:rgb(20, 20, 20);">异步时序问题</font>**

<font style="color:rgb(216, 222, 233);background-color:rgb(20, 20, 20);">多个节点同时异步加载时，后返回的children可能会覆盖前面已加载的children，进一步加剧节点丢失。</font>

解决方案：

1. 全局缓存已经加载完毕的children

:::color1
+ <font style="color:rgb(216, 222, 233);background-color:rgb(20, 20, 20);">用</font><font style="color:rgb(216, 222, 233);background-color:rgb(20, 20, 20);">一个全局</font><font style="color:rgb(216, 222, 233);background-color:rgb(20, 20, 20);">Map</font><font style="color:rgb(216, 222, 233);background-color:rgb(20, 20, 20);">（如</font><font style="background-color:rgb(20, 20, 20);">loadedChildren</font><font style="background-color:rgb(20, 20, 20);">Map</font><font style="color:rgb(216, 222, 233);background-color:rgb(20, 20, 20);">）缓存</font><font style="color:rgb(216, 222, 233);background-color:rgb(20, 20, 20);">每</font><font style="color:rgb(216, 222, 233);background-color:rgb(20, 20, 20);">个</font><font style="color:rgb(216, 222, 233);background-color:rgb(20, 20, 20);">节点</font><font style="color:rgb(216, 222, 233);background-color:rgb(20, 20, 20);">已</font><font style="color:rgb(216, 222, 233);background-color:rgb(20, 20, 20);">加载的</font><font style="color:rgb(216, 222, 233);background-color:rgb(20, 20, 20);">children</font><font style="color:rgb(216, 222, 233);background-color:rgb(20, 20, 20);">。</font>
+ <font style="color:rgb(216, 222, 233);background-color:rgb(20, 20, 20);">每次onLoadData时，把新加载的children缓存到Map中。</font>

:::

2.  只操作treeData

:::color1
+ <font style="color:rgb(216, 222, 233);background-color:rgb(20, 20, 20);">懒加载、异步加载、updateTreeData等只操作treeData，originTreeData只在初始化时cloneDeep一次。</font>

:::

3. 重置时递归完成合并树

:::color1
+ <font style="color:rgb(216, 222, 233);background-color:rgb(20, 20, 20);">重置时，不是简单cloneDeep originTreeData，而是递归地用缓存Map合成一棵“包含所有已加载children的完整树”。</font>

:::

4. 核心代码：

```tsx
// 1. 定义全局缓存
const loadedChildrenMap = useRef(new Map());

// 2. onLoadData时缓存children
const onLoadData = async ({ key }) => {
  // ...异步获取childrenNodesAndNode...
  loadedChildrenMap.current.set(key, childrenNodesAndNode);
  setTreeData((origin) => updateTreeData(_.cloneDeep(origin), key, childrenNodesAndNode));
};

// 3. 重置时递归合成完整树
function buildFullTree(root) {
  if (!root) return null;
  const children = loadedChildrenMap.current.get(root.key) || root.children;
  return {
    ...root,
    children: children ? children.map(buildFullTree) : undefined,
  };
}
useEffect(() => {
  setTreeData(originTreeData.map(buildFullTree));
}, [isResetTree]);
```







初始化树节点时需要使用_cloneDeep断开引用：

```tsx
setTreeData(_.cloneDeep(initTreeData));
setOriginTreeData(_.cloneDeep(initTreeData));
```

## **<font style="color:rgb(216, 222, 233);background-color:rgb(20, 20, 20);">全局缓存所有已加载children，重置时递归合成完整树</font>**<font style="color:rgb(216, 222, 233);background-color:rgb(20, 20, 20);">（推荐）</font>
+ <font style="color:rgb(216, 222, 233);background-color:rgb(20, 20, 20);">用</font><font style="color:rgb(216, 222, 233);background-color:rgb(20, 20, 20);">一个</font><font style="color:rgb(216, 222, 233);background-color:rgb(20, 20, 20);">Map</font><font style="color:rgb(216, 222, 233);background-color:rgb(20, 20, 20);">缓存所有</font><font style="color:rgb(216, 222, 233);background-color:rgb(20, 20, 20);">已</font><font style="color:rgb(216, 222, 233);background-color:rgb(20, 20, 20);">加载</font><font style="color:rgb(216, 222, 233);background-color:rgb(20, 20, 20);">过</font><font style="color:rgb(216, 222, 233);background-color:rgb(20, 20, 20);">的</font><font style="color:rgb(216, 222, 233);background-color:rgb(20, 20, 20);">children。</font>
+ <font style="color:rgb(216, 222, 233);background-color:rgb(20, 20, 20);">每</font><font style="color:rgb(216, 222, 233);background-color:rgb(20, 20, 20);">次on</font><font style="color:rgb(216, 222, 233);background-color:rgb(20, 20, 20);">Load</font><font style="color:rgb(216, 222, 233);background-color:rgb(20, 20, 20);">Data</font><font style="color:rgb(216, 222, 233);background-color:rgb(20, 20, 20);">时</font><font style="color:rgb(216, 222, 233);background-color:rgb(20, 20, 20);">，缓存</font><font style="color:rgb(216, 222, 233);background-color:rgb(20, 20, 20);">children</font><font style="color:rgb(216, 222, 233);background-color:rgb(20, 20, 20);">。</font>
+ <font style="color:rgb(216, 222, 233);background-color:rgb(20, 20, 20);">重置时递归合成完整树。</font>

代码：

```tsx
  // 2. onLoadData时缓存children
  const onLoadData = async ({ key }: any) => {
    let childrenNodesAndNode;
    if (key === "1") {
      const data = initialData;
      childrenNodesAndNode = createNodes(data, key);
    } else {
      const res = await dataSetService.queryFoldById(key);
      const data = res.data;
      childrenNodesAndNode = createNodes(data, key);
    }
    loadedChildrenMap.current.set(key, childrenNodesAndNode);
    setTreeData((origin) =>
      updateTreeData(_.cloneDeep(origin), key, childrenNodesAndNode)
    );
  };
 // 3. 重置时递归合成完整树
  function buildFullTree(root: any) {
    if (!root) return null;
    const children = loadedChildrenMap.current.get(root.key) || root.children;
    return {
      ...root,
      children: children ? children.map(buildFullTree) : undefined,
    };
  }
  useEffect(() => {
    setTreeData(originTreeData.map(buildFullTree));
  }, [isResetTree]);
```



> 更新: 2025-07-02 17:50:38  
> 原文: <https://www.yuque.com/quwaidi-exykz/lv0i4k/qm87unak3leazzfa>