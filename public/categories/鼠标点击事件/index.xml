<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>鼠标点击事件 on Amour verrouillé</title>
        <link>http://localhost:1313/categories/%E9%BC%A0%E6%A0%87%E7%82%B9%E5%87%BB%E4%BA%8B%E4%BB%B6/</link>
        <description>Recent content in 鼠标点击事件 on Amour verrouillé</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>en</language>
        <copyright>Example Person</copyright>
        <lastBuildDate>Mon, 08 Sep 2025 16:39:21 +0800</lastBuildDate><atom:link href="http://localhost:1313/categories/%E9%BC%A0%E6%A0%87%E7%82%B9%E5%87%BB%E4%BA%8B%E4%BB%B6/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>大屏中一些常用的css属性</title>
        <link>http://localhost:1313/p/%E5%A4%A7%E5%B1%8F%E4%B8%AD%E4%B8%80%E4%BA%9B%E5%B8%B8%E7%94%A8%E7%9A%84css%E5%B1%9E%E6%80%A7/</link>
        <pubDate>Mon, 08 Sep 2025 16:39:21 +0800</pubDate>
        
        <guid>http://localhost:1313/p/%E5%A4%A7%E5%B1%8F%E4%B8%AD%E4%B8%80%E4%BA%9B%E5%B8%B8%E7%94%A8%E7%9A%84css%E5%B1%9E%E6%80%A7/</guid>
        <description>&lt;ol&gt;
&lt;li&gt;&lt;font style=&#34;color:rgba(0, 0, 0, 0.9);background-color:rgb(245, 245, 245);&#34;&gt;width: fit-content;&lt;/font&gt;&lt;font style=&#34;color:#D22D8D;&#34;&gt;设置元素的宽度刚好能够容纳其内容;&lt;/font&gt;&lt;/li&gt;
&lt;li&gt;&lt;font style=&#34;color:rgba(0, 0, 0, 0.9);background-color:rgb(245, 245, 245);&#34;&gt;box-sizing: border-box;&lt;/font&gt;&lt;font style=&#34;color:#D22D8D;&#34;&gt;定义元素的盒模型（box model）的计算方式。它的作用是让元素的宽度和高度包括内容、内边距（padding）和边框（border），但不包括外边距（margin）。这与默认的盒模型（&lt;/font&gt;&lt;code&gt;&amp;lt;font style=&amp;quot;color:#D22D8D;background-color:rgba(0, 0, 0, 0.03);&amp;quot;&amp;gt;content-box&amp;lt;/font&amp;gt;&lt;/code&gt;&lt;font style=&#34;color:#D22D8D;&#34;&gt;）不同，在默认的盒模型中，宽度和高度只包括内容，不包括内边距和边框。&lt;/font&gt;&lt;/li&gt;
&lt;li&gt;&lt;font style=&#34;color:#000000;&#34;&gt;aspect-ratio: 4 / 3;&lt;/font&gt;&lt;font style=&#34;color:#D22D8D;&#34;&gt;用于保证元素的宽高比例不变；&lt;/font&gt;&lt;/li&gt;
&lt;li&gt;pointer-events;
&lt;ul&gt;
&lt;li&gt;auto:元素会按照正常的文档流顺序来响应鼠标事件。如果元素可见并且没有被其他元素遮挡，那么它就可以成为鼠标事件的目标。&lt;/li&gt;
&lt;li&gt;none:当设置为 &lt;code&gt;none&lt;/code&gt; 时，元素不会响应任何鼠标事件，即使鼠标悬停在元素上或点击元素。这相当于元素对于鼠标事件是“透明”的。然而，值得注意的是，&lt;code&gt;none&lt;/code&gt; 值不会影响元素的子元素。如果子元素没有设置 &lt;code&gt;pointer-events&lt;/code&gt; 属性，或者显式设置为 &lt;code&gt;auto&lt;/code&gt;，那么子元素仍然可以响应鼠标事件。&lt;/li&gt;
&lt;li&gt;visiblePainted：元素只有当它是可见的（即，它有内容，并且没有被 visibility 属性设置为 hidden）并且被绘制到屏幕上时，才会响应鼠标事件。&lt;/li&gt;
&lt;li&gt;visibleFill：元素只有在它是可见的，并且被绘制为一个填充区域（例如，背景颜色或图片）时，才会响应鼠标事件。&lt;/li&gt;
&lt;li&gt;visibleStroke：元素只有在它是可见的，并且被绘制为一个轮廓（例如，边框）时，才会响应鼠标事件。&lt;/li&gt;
&lt;li&gt;visible:元素只有在它是可见的时，才会响应鼠标事件。这包括了 &lt;code&gt;visiblePainted&lt;/code&gt;、&lt;code&gt;visibleFill&lt;/code&gt; 和 &lt;code&gt;visibleStroke&lt;/code&gt; 的所有情况。&lt;/li&gt;
&lt;li&gt;painted:元素只有在它被绘制到屏幕上时，才会响应鼠标事件，无论它是否可见。&lt;/li&gt;
&lt;li&gt;fill:元素只有在它被绘制为一个填充区域时，才会响应鼠标事件。&lt;/li&gt;
&lt;li&gt;stroke:元素只有在它被绘制为一个轮廓时，才会响应鼠标事件。&lt;/li&gt;
&lt;li&gt;使用场景：
&lt;ol&gt;
&lt;li&gt;auto:适用于普通元素，你希望它们能够正常响应鼠标事件。&lt;/li&gt;
&lt;li&gt;none:当你希望元素本身不响应鼠标事件，但允许事件穿透到下面的元素时。这在制作覆盖层或者需要鼠标事件穿透的场景中非常有用。&lt;/li&gt;
&lt;li&gt;visiblePainted、visibleFill、visibleStroke:这些值通常用于更精细的控制，例如，你可能希望一个元素只有在它有背景颜色时才响应鼠标事件。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
</description>
        </item>
        
    </channel>
</rss>
