[{"content":"handleScreenAuto 函数文档 目的 自适应调整数据大屏的显示，使其在不同分辨率的屏幕上保持设计稿的宽高比。\n函数逻辑 定义设计稿的宽度 (designDraftWidth) 和高度 (designDraftHeight)。 获取包含大屏元素 (#bigScreenV2) 的父元素 (documentElement)。 计算屏幕的宽高比与设计稿的宽高比，确定缩放比例 (scale)： 如果屏幕的宽高比小于设计稿的宽高比，则按宽度比例缩放。 否则，按高度比例缩放。 获取大屏元素 (dom) 并应用缩放和平移变换： 使用 transform 属性设置缩放和平移。 计算调整后的大屏元素的宽度和高度，并设置到地图组件的宽度和高度 (setMapWidthAndHeight)。 示例代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 const handleScreenAuto = () =\u0026gt; { const designDraftWidth = 1920; // 设计稿的宽度 const designDraftHeight = 1080; // 设计稿的高度 const documentElement = largeScreenV2Ref.current.parentElement; // 根据屏幕的变化适配的比例 const scale = documentElement.clientWidth / documentElement.clientHeight \u0026lt; designDraftWidth / designDraftHeight ? documentElement.clientWidth / designDraftWidth : documentElement.clientHeight / designDraftHeight; // 缩放比例 const dom = document.querySelector(\u0026#34;#bigScreenV2\u0026#34;) as any; dom.style.transform = `scale(${scale}) translate(-50%)`; // 尝试重置地球的缩放比例 const width = (dom.clientWidth * scale).toFixed(2); const height = (dom.clientHeight * scale).toFixed(2); setMapWidthAndHeight({ width, height, }); }; useEffect(() =\u0026gt; { if (largeScreenV2Ref.current) { //初始化自适应 ----在刚显示的时候就开始适配一次 handleScreenAuto(); //绑定自适应函数 ---防止浏览器栏变化后不再适配 window.onresize = () =\u0026gt; handleScreenAuto(); //退出大屏后自适应消失 ---这是react的组件销毁生命周期 } return () =\u0026gt; { window.onresize = null; }; }, [largeScreenV2Ref]); return ( \u0026lt;div className=\u0026#34;center-v2\u0026#34; ref={largeScreenV2Ref}\u0026gt; \u0026lt;div id=\u0026#34;bigScreenV2\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; ); 1 2 3 4 5 6 7 8 9 10 #bigScreenV2 { display: inline-block; width: 1920px; //设计稿的宽度 height: 1080px; //设计稿的高度 transform-origin: 0 0; position: absolute; pointer-events:none; left: 50%; z-index: 2; } 注意事项 确保 largeScreenV2Ref 引用的元素存在且已正确初始化。 该函数假设大屏元素 (#bigScreenV2) 是绝对定位的，并且其父元素是相对定位的。 该函数可能需要在窗口大小变化时调用，例如通过监听 window.resize 事件。 使用场景 当需要在不同分辨率的屏幕上保持数据大屏的布局和比例时。 当需要动态调整地图组件的大小以适应大屏元素的变化时。 ","date":"2025-09-08T16:50:59+08:00","permalink":"http://localhost:54040/p/%E5%A4%A7%E5%B1%8F%E8%87%AA%E9%80%82%E5%BA%94%E5%87%BD%E6%95%B0/","title":"大屏自适应函数"},{"content":" width: fit-content;设置元素的宽度刚好能够容纳其内容; box-sizing: border-box;定义元素的盒模型（box model）的计算方式。它的作用是让元素的宽度和高度包括内容、内边距（padding）和边框（border），但不包括外边距（margin）。这与默认的盒模型（\u0026lt;font style=\u0026quot;color:#D22D8D;background-color:rgba(0, 0, 0, 0.03);\u0026quot;\u0026gt;content-box\u0026lt;/font\u0026gt;）不同，在默认的盒模型中，宽度和高度只包括内容，不包括内边距和边框。 aspect-ratio: 4 / 3;用于保证元素的宽高比例不变； pointer-events; auto:元素会按照正常的文档流顺序来响应鼠标事件。如果元素可见并且没有被其他元素遮挡，那么它就可以成为鼠标事件的目标。 none:当设置为 none 时，元素不会响应任何鼠标事件，即使鼠标悬停在元素上或点击元素。这相当于元素对于鼠标事件是“透明”的。然而，值得注意的是，none 值不会影响元素的子元素。如果子元素没有设置 pointer-events 属性，或者显式设置为 auto，那么子元素仍然可以响应鼠标事件。 visiblePainted：元素只有当它是可见的（即，它有内容，并且没有被 visibility 属性设置为 hidden）并且被绘制到屏幕上时，才会响应鼠标事件。 visibleFill：元素只有在它是可见的，并且被绘制为一个填充区域（例如，背景颜色或图片）时，才会响应鼠标事件。 visibleStroke：元素只有在它是可见的，并且被绘制为一个轮廓（例如，边框）时，才会响应鼠标事件。 visible:元素只有在它是可见的时，才会响应鼠标事件。这包括了 visiblePainted、visibleFill 和 visibleStroke 的所有情况。 painted:元素只有在它被绘制到屏幕上时，才会响应鼠标事件，无论它是否可见。 fill:元素只有在它被绘制为一个填充区域时，才会响应鼠标事件。 stroke:元素只有在它被绘制为一个轮廓时，才会响应鼠标事件。 使用场景： auto:适用于普通元素，你希望它们能够正常响应鼠标事件。 none:当你希望元素本身不响应鼠标事件，但允许事件穿透到下面的元素时。这在制作覆盖层或者需要鼠标事件穿透的场景中非常有用。 visiblePainted、visibleFill、visibleStroke:这些值通常用于更精细的控制，例如，你可能希望一个元素只有在它有背景颜色时才响应鼠标事件。 ","date":"2025-09-08T16:39:21+08:00","permalink":"http://localhost:54040/p/%E5%A4%A7%E5%B1%8F%E4%B8%AD%E4%B8%80%E4%BA%9B%E5%B8%B8%E7%94%A8%E7%9A%84css%E5%B1%9E%E6%80%A7/","title":"大屏中一些常用的css属性"},{"content":"leaflet格网的作用：希望格网的间距与地图的缩放层级相关联，并且格网的大小应该类似于地图瓦片的分辨率。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Leaflet 动态格网示例\u0026lt;/title\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://unpkg.com/leaflet/dist/leaflet.css\u0026#34; /\u0026gt; \u0026lt;style\u0026gt; #map { height: 100vh; width: 100%; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;map\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script src=\u0026#34;https://unpkg.com/leaflet/dist/leaflet.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; // 初始化地图 var map = L.map(\u0026#39;map\u0026#39;, { center: [39.9042, 116.4074], // 以北京为例 zoom: 13, minZoom: 5, maxZoom: 18 }); // 添加默认瓦片图层 L.tileLayer(\u0026#39;https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png\u0026#39;, { attribution: \u0026#39;Map data \u0026amp;copy; \u0026lt;a href=\u0026#34;https://www.openstreetmap.org/copyright\u0026#34;\u0026gt;OpenStreetMap\u0026lt;/a\u0026gt; contributors\u0026#39; }).addTo(map); // 动态绘制格网 function drawGrid() { // 获取当前地图层级 const currentZoom = map.getZoom() // 清除旧的格网 map.eachLayer(function (layer) { if (layer instanceof L.Polyline) { map.removeLayer(layer); } }); if (currentZoom \u0026gt;= 15) { return } var zoom = map.getZoom(); var bounds = map.getBounds(); // 计算当前缩放层级下的分辨率 var resolution = 180 / Math.pow(2, zoom); // 计算格网的起始点 var minLat = Math.floor(bounds.getSouth() / resolution) * resolution; var maxLat = Math.ceil(bounds.getNorth() / resolution) * resolution; var minLng = Math.floor(bounds.getWest() / resolution) * resolution; var maxLng = Math.ceil(bounds.getEast() / resolution) * resolution; // 经度格网 for (var lng = minLng; lng \u0026lt;= maxLng; lng += resolution) { L.polyline([ [minLat, lng], [maxLat, lng] ], { color: \u0026#39;blue\u0026#39;, weight: 1 }).addTo(map); } // 纬度格网 for (var lat = minLat; lat \u0026lt;= maxLat; lat += resolution) { L.polyline([ [lat, minLng], [lat, maxLng] ], { color: \u0026#39;blue\u0026#39;, weight: 1 }).addTo(map); } } // 初始化格网 drawGrid(); // 监听地图缩放事件，动态更新格网 map.on(\u0026#39;zoomend\u0026#39;, drawGrid); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; ","date":"2025-09-08T13:35:07+08:00","permalink":"http://localhost:54040/p/leaflet%E6%B7%BB%E5%8A%A0%E6%A0%BC%E7%BD%91demo/","title":"leaflet添加格网demo"},{"content":"React的渲染机制基于虚拟dom的概念。虚拟dom是真实dom的js对象的表示，React通过比较虚拟DOM的变化来高效的真实更新DOM,从而减少不必要的DOM操作，用于提高性能。\n类组件的生命周期：\n构造函数(constructor)：初始化组件的状态和绑定事件处理函数（组件实例化时调用一次） 1 2 3 4 5 6 class MyComponent extends React.Component { constructor(props) { super(props); this.state = { count: 0 }; } } 组件挂载(componentDidMount):组件挂载后调用一次： 1 2 3 4 5 componentDidMount() { fetch(\u0026#39;https://api.example.com/data\u0026#39;) .then(response =\u0026gt; response.json()) .then(data =\u0026gt; this.setState({ data })); } 组件更新: shouldComponentUpdate:决定组件是否需要重新渲染，可以避免不必要的渲染；组件接受到新的props和state时调用。 1 2 3 shouldComponentUpdate(nextProps, nextState) { return nextState.count !== this.state.count; } getSnapshotBeforeUpdate:在组件更新之前捕获DOM的状态，例如滚动位置等。返回一个值，该值将作为componentDidUpdate的第三个参数。 1 2 3 4 5 6 getSnapshotBeforeUpdate(prevProps, prevState) { if (prevProps.data !== this.props.data) { return this.someRef.current.scrollTop; } return null; } componentDidUpdate:组件更新完成后调用（主要用于更新DOM） 1 2 3 4 5 componentDidUpdate(prevProps, prevState, snapshot) { if (snapshot !== null) { this.someRef.current.scrollTop = snapshot; } } 组件卸载(componentWillUnmount)：组件卸载时调用（清理资源、取消订阅、清理定时器等） 1 2 3 componentWillUnmount() { clearInterval(this.timer); } 函数组件生命周期：\nuseState: useEffect: useLayoutEffect:会在所有DOM变更之后同步调用，可以用于读取DOM布局并同步重新渲染 useMemo:用于缓存计算值，避免不必要的计算。 useCallback:用于缓存函数，避免不必要的函数重新创建 useRef:创建一个可变的引用，其值在组件的整个生命周期内保持不变 useImperativeHandle:用于自定义暴露给父组件的实例值 useReducer: useContext: ","date":"2025-09-08T13:17:13+08:00","permalink":"http://localhost:54040/p/react%E7%B1%BB%E7%BB%84%E4%BB%B6%E5%92%8C%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6%E7%9A%84%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6%E4%BB%A5%E5%8F%8A%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0/","title":"react类组件和函数组件的渲染机制以及钩子函数"},{"content":"在 Web 地图开发中，瓦片（Tile）是地图数据的基本单位。不同坐标系（如 EPSG:3857 和 EPSG:4326）的瓦片边界计算方式不同，直接影响地图渲染和数据查询的准确性。本文档详细说明两种坐标系下的瓦片边界计算方法，并提供代码实现。\n坐标系简介：\n坐标系 名称 单位 适用范围 特点 EPSG:3857 Web 墨卡托 米（meters） Google Maps、OpenStreetMap 适用于 Web 地图，高纬度地区变形严重 EPSG:4326 WGS84 经纬度 度（degrees） 传统 GIS 系统 直接使用经纬度，无投影变形 瓦片边界计算：\nEPSG:4326(WGS84经纬度)\nEPSG:3857(Web墨卡托)获取瓦片的蜜汁坐标范围转换为经纬度 EPSG:3857(Web墨卡托)获取瓦片的蜜汁坐标范围转换为经纬度 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 tileLatLonBounds(x,y,zoom){ const map=L.map(\u0026#39;map\u0026#39;,{ // 使用4326坐标系 } const tilesize=256; const nwPoint=L.point(x*tileSize,(y+1)*tileSize); const sePoint=L.point((x+1)*tilesize,y*tilesize); const nw=map.unproject(nwPoint,zoom) const se=map.unproject(sePoint,zoom); return { x1:nw.lng; y1:nw.lat; x2:se.lng; y2:se.lat; } } EPSG:3857(web墨卡托)\n获取瓦片的坐标范围 转换为经纬度 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 pixelsToMeters2(x, y, zoom) { let res = this.resolution(zoom); let mx = x * res - (2 * Math.PI * 6378137) / 2.0; let my = y * res - (2 * Math.PI * 6378137) / 2.0; return { x: mx, y: Math.abs(my) }; } tileBounds(x, y, zoom) { let minPoints = this.pixelsToMeters2(x * 256, y * 256, zoom); let maxPoints = this.pixelsToMeters2((x + 1) * 256, (y + 1) * 256, zoom); return { x1: minPoints.x, x2: maxPoints.x, y1: maxPoints.y, y2: minPoints.y, }; } MetersToLatLon(x, y) { let lon = (x / ((2 * Math.PI * 6378137) / 2.0)) * 180.0; let lat = (y / ((2 * Math.PI * 6378137) / 2.0)) * 180.0; lat = (180 / Math.PI) * (2 * Math.atan(Math.exp((lat * Math.PI) / 180.0)) - Math.PI / 2.0); return { lat: lat, lon: lon }; } tileLatLonBounds(x, y, zoom) { let crs = MapContent._crs; let envelope = this.tileBounds(x, y, zoom); let minLatLon = this.MetersToLatLon(envelope.x1, envelope.y1); let maxLatLon = this.MetersToLatLon(envelope.x2, envelope.y2); return { x1: minLatLon.lon, x2: maxLatLon.lon, y1: minLatLon.lat, y2: maxLatLon.lat, }; } ","date":"2025-09-08T10:18:14+08:00","permalink":"http://localhost:54040/p/leaflet%E4%B8%8D%E5%90%8C%E5%9D%90%E6%A0%87%E7%B3%BB%E4%B8%8B%E7%93%A6%E7%89%87%E8%BE%B9%E7%95%8C%E8%AE%A1%E7%AE%97%E6%96%B9%E6%B3%95/","title":"leaflet不同坐标系下，瓦片边界计算方法"},{"content":"数组转对象时的顺序问题 数组转对象的常见方式： 1 2 3 4 5 6 7 8 9 10 11 const arr = [ { id: 3, name: \u0026#39;Tom\u0026#39; }, { id: 1, name: \u0026#39;Jerry\u0026#39; }, { id: 2, name: \u0026#39;Spike\u0026#39; } ]; // 方式一：普通对象（数字或数字字符串作为 key） const obj = {}; arr.forEach(item =\u0026gt; { obj[item.id] = item; }); 遭遇的问题： 当对象的 key 是数字或类似数字的字符串（如 \u0026lt;font style=\u0026quot;color:rgba(0, 0, 0, 0.9);background-color:rgba(0, 0, 0, 0.03);\u0026quot;\u0026gt;'1'\u0026lt;/font\u0026gt;, \u0026lt;font style=\u0026quot;color:rgba(0, 0, 0, 0.9);background-color:rgba(0, 0, 0, 0.03);\u0026quot;\u0026gt;'2'\u0026lt;/font\u0026gt;, \u0026lt;font style=\u0026quot;color:rgba(0, 0, 0, 0.9);background-color:rgba(0, 0, 0, 0.03);\u0026quot;\u0026gt;'3'\u0026lt;/font\u0026gt;）时，JavaScript 引擎会自动按照数字升序排列这些 key。 因此，转换后的对象属性顺序无法保证与原始数组顺序一致。 解决方案：使用map数据结构 1 2 3 4 5 6 7 8 const map = new Map(); arr.forEach(item =\u0026gt; { map.set(item.id, item); }); // 遍历 Map，顺序与数组一致 map.forEach((value, key) =\u0026gt; { console.log(key, value); }); Map 是 ES6 引入的数据结构，专门用于保存键值对。 Map 会严格记住键的插入顺序，遍历时会按照插入顺序返回键值对。 ","date":"2025-09-08T10:12:49+08:00","permalink":"http://localhost:54040/p/%E6%9C%80%E8%BF%91%E9%81%87%E5%88%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E6%9C%89%E5%85%B3%E5%AF%B9%E8%B1%A1%E7%9A%84%E9%97%AE%E9%A2%98/","title":"最近遇到的一些有关对象的问题"}]