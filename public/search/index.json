[{"content":"Leaflet 地图最大层级自定义占位图解决方案 设计思路 监听地图缩放事件，检测是否达到最大层级 使用瓦片错误处理机制替换无法加载的瓦片 提供用户友好的提示信息 添加美观的UI和交互效果 实现原理 监听瓦片错误事件(就说所有返回的状态码不为200)\n将请求失败的瓦片替换成自定义占位图\n检测最大缩放层级，自动应用占位图\n关键代码：我是在react应用中编写的\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 // 新增：设置瓦片错误处理 setupTileErrorHandling = (layer) =\u0026gt; { if (layer \u0026amp;\u0026amp; layer.getLayer) { const leafletLayer = layer.getLayer(); // 设置错误占位图 if (leafletLayer.options) { leafletLayer.options.errorTileUrl = \u0026#39;https://t1.tianditu.gov.cn/DataServer?T=img_c\u0026amp;x=426805\u0026amp;y=79274\u0026amp;l=19\u0026amp;tk=9d3512a6ad161b05ac68a7fecf05b119\u0026#39;; } // 监听瓦片错误事件 leafletLayer.on(\u0026#39;tileerror\u0026#39;, (error) =\u0026gt; { this.handleTileError(error); }); } }; // 新增：处理瓦片错误 handleTileError = (error) =\u0026gt; { const { tile, url } = error; // 使用自定义占位图替换失败的瓦片 if ( tile \u0026amp;\u0026amp; tile.src !== \u0026#39;https://t1.tianditu.gov.cn/DataServer?T=img_c\u0026amp;x=426805\u0026amp;y=79274\u0026amp;l=19\u0026amp;tk=9d3512a6ad161b05ac68a7fecf05b119\u0026#39; ) { tile.src = \u0026#39;https://t1.tianditu.gov.cn/DataServer?T=img_c\u0026amp;x=426805\u0026amp;y=79274\u0026amp;l=19\u0026amp;tk=9d3512a6ad161b05ac68a7fecf05b119\u0026#39;; } }; 至于什么时候调用setupTileErrorHandling这个函数，就是在你每次添加图层到地图上时，就像上图这样\n代码示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;zh-CN\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Leaflet 最大层级占位图解决方案\u0026lt;/title\u0026gt; \u0026lt;!-- Leaflet CSS --\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://unpkg.com/leaflet@1.9.4/dist/leaflet.css\u0026#34; /\u0026gt; \u0026lt;style\u0026gt; * { margin: 0; padding: 0; box-sizing: border-box; } body { font-family: \u0026#39;Segoe UI\u0026#39;, Tahoma, Geneva, Verdana, sans-serif; line-height: 1.6; color: #333; background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%); min-height: 100vh; padding: 20px; } .container { max-width: 1200px; margin: 0 auto; } header { text-align: center; margin-bottom: 30px; padding: 20px; background: white; border-radius: 10px; box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1); } h1 { color: #2c3e50; margin-bottom: 10px; } .description { color: #7f8c8d; max-width: 800px; margin: 0 auto; } .map-container { display: flex; gap: 20px; flex-wrap: wrap; } .map-wrapper { flex: 1; min-width: 300px; border-radius: 10px; overflow: hidden; box-shadow: 0 6px 16px rgba(0, 0, 0, 0.15); background: white; padding: 15px; } #map { height: 500px; width: 100%; border-radius: 8px; z-index: 1; } .instructions { flex: 1; min-width: 300px; background: white; border-radius: 10px; padding: 20px; box-shadow: 0 6px 16px rgba(0, 0, 0, 0.15); } .instructions h2 { color: #2c3e50; margin-bottom: 15px; padding-bottom: 10px; border-bottom: 2px solid #ecf0f1; } .step { margin-bottom: 15px; padding: 15px; background: #f8f9fa; border-radius: 8px; border-left: 4px solid #3498db; } .step-number { display: inline-block; width: 28px; height: 28px; background: #3498db; color: white; text-align: center; line-height: 28px; border-radius: 50%; margin-right: 10px; } .code-block { background: #2d3436; color: #dfe6e9; padding: 12px; border-radius: 6px; overflow-x: auto; margin: 15px 0; font-family: \u0026#39;Courier New\u0026#39;, monospace; font-size: 14px; } .custom-tile { display: block; margin: 20px auto; max-width: 100%; border-radius: 8px; box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2); } .notification { position: fixed; bottom: 20px; right: 20px; padding: 15px 20px; background: #27ae60; color: white; border-radius: 8px; box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2); transform: translateY(100px); opacity: 0; transition: transform 0.3s, opacity 0.3s; z-index: 1000; } .notification.show { transform: translateY(0); opacity: 1; } @media (max-width: 768px) { .map-container { flex-direction: column; } #map { height: 400px; } } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;header\u0026gt; \u0026lt;h1\u0026gt;Leaflet 地图最大层级占位图解决方案\u0026lt;/h1\u0026gt; \u0026lt;p class=\u0026#34;description\u0026#34;\u0026gt; 当地图放大到最大层级时，使用自定义占位图替代空白瓦片，提升用户体验。 \u0026lt;/p\u0026gt; \u0026lt;/header\u0026gt; \u0026lt;div class=\u0026#34;map-container\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;map-wrapper\u0026#34;\u0026gt; \u0026lt;div id=\u0026#34;map\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;img src=\u0026#34;https://t1.tianditu.gov.cn/DataServer?T=img_c\u0026amp;x=426805\u0026amp;y=79274\u0026amp;l=19\u0026amp;tk=9d3512a6ad161b05ac68a7fecf05b119\u0026#34; alt=\u0026#34;占位图示例\u0026#34; class=\u0026#34;custom-tile\u0026#34;\u0026gt; \u0026lt;p\u0026gt;\u0026lt;strong\u0026gt;提示：\u0026lt;/strong\u0026gt; 尝试将地图放大到最大层级，查看占位图效果。\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;notification\u0026#34; id=\u0026#34;notification\u0026#34;\u0026gt; 已放大到最大层级，显示自定义占位图 \u0026lt;/div\u0026gt; \u0026lt;!-- Leaflet JS --\u0026gt; \u0026lt;script src=\u0026#34;https://unpkg.com/leaflet@1.9.4/dist/leaflet.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; // 初始化地图 const map = L.map(\u0026#39;map\u0026#39;).setView([39.9042, 116.4074], 13); // 北京市中心 // 添加默认图层 const osmLayer = L.tileLayer(\u0026#39;http://10.17.17.243/arcgis/{z}/{y}/{x}.png\u0026#39;, { attribution: \u0026#39;\u0026amp;copy; \u0026lt;a href=\u0026#34;https://www.openstreetmap.org/copyright\u0026#34;\u0026gt;OpenStreetMap\u0026lt;/a\u0026gt; contributors\u0026#39;, maxZoom: 19 }); // 添加天地图图层（作为示例） const tiandituLayer = L.tileLayer(\u0026#39;http://10.17.17.243/arcgis/{z}/{y}/{x}.png\u0026#39;, { // subdomains: [\u0026#39;0\u0026#39;, \u0026#39;1\u0026#39;, \u0026#39;2\u0026#39;, \u0026#39;3\u0026#39;, \u0026#39;4\u0026#39;, \u0026#39;5\u0026#39;, \u0026#39;6\u0026#39;, \u0026#39;7\u0026#39;], maxZoom: 22 }); // 设置瓦片错误处理 function setupTileErrorHandling(layer) { const leafletLayer = layer; // 设置错误占位图 if (leafletLayer.options) { leafletLayer.options.errorTileUrl = \u0026#39;https://via.placeholder.com/256x256/3498db/ffffff?text=自定义瓦片\u0026#39;; } // 监听瓦片错误事件 leafletLayer.on(\u0026#39;tileerror\u0026#39;, function(error) { handleTileError(error); }); } // 处理瓦片错误 function handleTileError(error) { const { tile } = error; // 使用自定义占位图替换失败的瓦片 if (tile) { tile.src = \u0026#39;https://t1.tianditu.gov.cn/DataServer?T=img_c\u0026amp;x=426805\u0026amp;y=79274\u0026amp;l=19\u0026amp;tk=9d3512a6ad161b05ac68a7fecf05b119\u0026#39;; } } // 添加图层到地图 osmLayer.addTo(map); setupTileErrorHandling(osmLayer); // 添加图层控制 const baseMaps = { \u0026#34;OpenStreetMap\u0026#34;: osmLayer, \u0026#34;天地图\u0026#34;: tiandituLayer }; L.control.layers(baseMaps).addTo(map); // 监听地图缩放事件 map.on(\u0026#39;zoomend\u0026#39;, function() { if (map.getZoom() === map.getMaxZoom()) { // 显示通知 const notification = document.getElementById(\u0026#39;notification\u0026#39;); notification.classList.add(\u0026#39;show\u0026#39;); // 3秒后隐藏通知 setTimeout(function() { notification.classList.remove(\u0026#39;show\u0026#39;); }, 3000); } }); // 添加缩放控件 L.control.zoom({ position: \u0026#39;bottomright\u0026#39; }).addTo(map); // 添加比例尺 L.control.scale({ imperial: false, position: \u0026#39;bottomleft\u0026#39; }).addTo(map); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 上述代码可以直接运行，可以将底图的url换成给自己的，自定义占位符的url也可以自己更换。\n效果如下：\n","date":"2025-09-17T16:55:19+08:00","permalink":"http://localhost:1313/p/%E5%85%B3%E4%BA%8E%E6%94%BE%E5%A4%A7leaflet%E5%BA%95%E5%9B%BE%E8%87%B3%E6%9C%80%E5%A4%A7%E5%B1%82%E7%BA%A7%E5%90%8E%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8D%A0%E4%BD%8D%E5%9B%BE%E7%9A%84%E8%A7%86%E7%BA%BF%E6%AD%A5%E9%AA%A4/","title":"关于放大leaflet底图至最大层级后自定义占位图的视线步骤"},{"content":"React-Spring动画库介绍 react官网中提到的动画库有3个：React Transition Group\\React MOtion以及React-Spring.其中React-Spring动画库社区最活跃，代码更新频次最高，文档也较完善；\n优势：react-spring是一个基于弹簧物理学的动画库，灵感来自animated和react-motion，它继承了animated库的插值和性能以及react-motion的易用性，react-spring库提供了两种api:hooks api(只能写在函数组件中，写在类组件中会报错);Render-props api。\n性能：最核心的一点就是每次动画属性改变不会引起组件重新render,而是直接修改了dom上的相关属性。所以这个动画效果就更接近真实世界。\n注意，在使用该库之前，要注意react-spring/web这个的版本，react18版本的项目适配于react-spring/web@9.7.3,之前没有指定版本导致下载下来的版本是10，在使用useTransition这个钩子的时候一直报：\n1 ncaught TypeError: Cannot add property ref, object is not extensible Hook Api介绍 useSpring:创建一个单独的简单动画Spring(a-位置\u0026gt;b位置)的单独动画。\nuseSprings:就是创建多个不同动画。用于列表。\nuseTrail:创建一组依次执行的Spring-多个弹簧(相同)，一个弹簧在另一个弹簧之后。\nuseTransition:添加组件挂载或卸载等生命周期变化时的动画。\nuseChain:用于自定义spring执行顺序。\ndemo:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 import \u0026#34;./styles.css\u0026#34;; import React, { useState, useRef } from \u0026#34;react\u0026#34;; import data from \u0026#34;./data\u0026#34;; import { useSpring, useSprings, useTrail, useChain, useTransition, animated, useSpringRef } from \u0026#34;react-spring\u0026#34;; export default function App() { return ( \u0026lt;div className=\u0026#34;App\u0026#34;\u0026gt; \u0026lt;Spring1\u0026gt;\u0026lt;/Spring1\u0026gt; \u0026lt;Spring2\u0026gt;\u0026lt;/Spring2\u0026gt; \u0026lt;Springs\u0026gt;\u0026lt;/Springs\u0026gt; \u0026lt;Trails\u0026gt;\u0026lt;/Trails\u0026gt; \u0026lt;Chains\u0026gt;\u0026lt;/Chains\u0026gt; \u0026lt;/div\u0026gt; ); } export const Spring1 = () =\u0026gt; { const [show, setShow] = useState(false); const spring = useSpring({ from: { opacity: 0, // transform: \u0026#39;translateY(0px)\u0026#39; y: 300 //v9新写法 // rotateZ: 180, }, to: { opacity: 1, // transform: \u0026#39;translateY(200px)\u0026#39; y: 0 // rotateZ: 0, }, reverse: show,//设置动画移动的方向，为false就从from-\u0026gt;to,反之相反。 // native: false, // delay: 1000, config: { mass: 1, //弹簧质量：回弹惯性，质量越大惯性越大 tension: 100 //弹簧张力：影响整体速度，张力越紧速度越快 // friction: 5,//摩擦力：可以与mass、tension的效果相互抵消 } }); const spring1 = useSpring({ //另一种写法 opacity: show ? 1 : 0, transform: show ? \u0026#34;translateY(0px)\u0026#34; : \u0026#34;translateY(200px)\u0026#34; }); return ( \u0026lt;div className=\u0026#34;wrapper\u0026#34;\u0026gt; \u0026lt;h2\u0026gt;一、useSpring钩子基本用法：创建一个单独的简单动画Spring\u0026lt;/h2\u0026gt; \u0026lt;h3\u0026gt;从a→b移动数据的单个弹簧\u0026lt;/h3\u0026gt; \u0026lt;div className=\u0026#34;box\u0026#34;\u0026gt; \u0026lt;div className=\u0026#34;flex1\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;animated.div className=\u0026#34;box1\u0026#34; style={spring}\u0026gt; 向上滑动 \u0026lt;/animated.div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;button onClick={() =\u0026gt; setShow((v) =\u0026gt; !v)} className=\u0026#34;mybtn\u0026#34;\u0026gt; 切换 \u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); }; const Qwe = () =\u0026gt; { return \u0026lt;div\u0026gt;1\u0026lt;/div\u0026gt;; }; export const Spring2 = () =\u0026gt; { const [show, setShow] = useState(false); const spring = useSpring({ from: { h: 40 }, to: { h: 200 }, reverse: show, // delay: 1000, config: { mass: 5 //弹簧质量：回弹惯性，质量越大惯性越大 // tension: 300,//弹簧张力：影响整体速度，张力越紧速度越快 // friction: 5,//摩擦力：可以与mass、tension的效果相互抵消 } }); const spring2 = useSpring({ from: { height: \u0026#34;40px\u0026#34; }, to: { height: \u0026#34;200px\u0026#34;, backgroundColor: \u0026#34;blue\u0026#34; }, reverse: show // delay: 1000, }); return ( \u0026lt;div className=\u0026#34;wrapper\u0026#34;\u0026gt; \u0026lt;h2\u0026gt;useSpring插值\u0026lt;/h2\u0026gt; \u0026lt;div className=\u0026#34;box\u0026#34;\u0026gt; \u0026lt;div className=\u0026#34;flex1\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div style={{ display: \u0026#34;flex\u0026#34;, alignItems: \u0026#34;flex-end\u0026#34;, justifyContent: \u0026#34;center\u0026#34; }} \u0026gt; \u0026lt;animated.div className=\u0026#34;box2\u0026#34; style={{ background: \u0026#34;yellow\u0026#34;, // height: spring.h.interpolate((height) =\u0026gt; `${height}px`) // height: spring.h.to((height) =\u0026gt; `${height}px`) //v9 interpolate替换为to height: spring.h.to({ range: [40, 100, 150, 200], output: [\u0026#34;40px\u0026#34;, \u0026#34;30px\u0026#34;, \u0026#34;250px\u0026#34;, \u0026#34;200px\u0026#34;] }) //v9 interpolate替换为to }} \u0026gt; {/* \u0026lt;Qwe\u0026gt;\u0026lt;/Qwe\u0026gt; */} {spring.h.to((height) =\u0026gt; `${height}`)} \u0026lt;/animated.div\u0026gt; \u0026lt;animated.div className=\u0026#34;box2\u0026#34; style={spring2}\u0026gt; 2 \u0026lt;/animated.div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;button onClick={() =\u0026gt; setShow((v) =\u0026gt; !v)} className=\u0026#34;mybtn\u0026#34;\u0026gt; 切换 \u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); }; export const Springs = () =\u0026gt; { const [show, setShow] = useState(false); const springs = useSprings(5, [ { from: { height: \u0026#34;40px\u0026#34; }, to: { height: \u0026#34;100px\u0026#34;, backgroundColor: \u0026#34;yellow\u0026#34; }, reverse: show, config: { mass: 1 //弹簧质量：回弹惯性，质量越大惯性越大 } }, { from: { height: \u0026#34;40px\u0026#34; }, to: { height: \u0026#34;150px\u0026#34;, backgroundColor: \u0026#34;blue\u0026#34; }, reverse: show, config: { mass: 3 //弹簧质量：回弹惯性，质量越大惯性越大 } }, { from: { height: \u0026#34;40px\u0026#34;, scaleX: 1 }, to: { height: \u0026#34;200px\u0026#34;, scaleX: 2, backgroundColor: \u0026#34;green\u0026#34; }, reverse: show, config: { mass: 5 //弹簧质量：回弹惯性，质量越大惯性越大 } }, { from: { height: \u0026#34;40px\u0026#34; }, to: { height: \u0026#34;150px\u0026#34;, backgroundColor: \u0026#34;purple\u0026#34; }, reverse: show, config: { mass: 8 //弹簧质量：回弹惯性，质量越大惯性越大 } }, { from: { height: \u0026#34;40px\u0026#34; }, to: { height: \u0026#34;100px\u0026#34;, backgroundColor: \u0026#34;orange\u0026#34; }, reverse: show, config: { mass: 11 //弹簧质量：回弹惯性，质量越大惯性越大 } } ]); return ( \u0026lt;div className=\u0026#34;wrapper\u0026#34;\u0026gt; \u0026lt;h2\u0026gt;二、useSprings用法：创建一组同时执行的Spring\u0026lt;/h2\u0026gt; \u0026lt;h3\u0026gt;多个弹簧(不同)，用于列表，每个弹簧从a→b移动数据\u0026lt;/h3\u0026gt; \u0026lt;div className=\u0026#34;box\u0026#34;\u0026gt; \u0026lt;div className=\u0026#34;flex1\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div style={{ display: \u0026#34;flex\u0026#34;, alignItems: \u0026#34;flex-end\u0026#34;, justifyContent: \u0026#34;space-between\u0026#34; }} \u0026gt; {springs.map((item, index) =\u0026gt; { return ( \u0026lt;animated.div className=\u0026#34;box2\u0026#34; key={index} style={item}\u0026gt; {index} \u0026lt;/animated.div\u0026gt; ); })} \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;button onClick={() =\u0026gt; setShow((v) =\u0026gt; !v)} className=\u0026#34;mybtn\u0026#34;\u0026gt; 切换 \u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); }; export const Trails = () =\u0026gt; { const [show, setShow] = useState(false); const springs = useTrail(6, { from: { height: \u0026#34;40px\u0026#34; }, to: { height: \u0026#34;200px\u0026#34;, backgroundColor: `rgb(${Math.floor(Math.random() * 256)},${Math.floor( Math.random() * 256 )},${Math.floor(Math.random() * 256)})` }, reverse: show, config: { mass: 1 //弹簧质量：回弹惯性，质量越大惯性越大 } }); return ( \u0026lt;div className=\u0026#34;wrapper\u0026#34;\u0026gt; \u0026lt;h2\u0026gt;三、useTrail用法：创建一组依次执行的Spring\u0026lt;/h2\u0026gt; \u0026lt;h3\u0026gt;多个弹簧(相同)，一个弹簧在另一个弹簧之后/跟随\u0026lt;/h3\u0026gt; \u0026lt;div className=\u0026#34;box\u0026#34;\u0026gt; \u0026lt;div className=\u0026#34;flex1\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div style={{ display: \u0026#34;flex\u0026#34;, alignItems: \u0026#34;flex-end\u0026#34;, justifyContent: \u0026#34;center\u0026#34; }} \u0026gt; {springs.map((item, index) =\u0026gt; { return ( \u0026lt;animated.div className=\u0026#34;box2\u0026#34; key={index} style={item}\u0026gt; {index} \u0026lt;/animated.div\u0026gt; ); })} \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;button onClick={() =\u0026gt; setShow((v) =\u0026gt; !v)} className=\u0026#34;mybtn\u0026#34;\u0026gt; 切换 \u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); }; export const Chains = () =\u0026gt; { const [show, setShow] = useState(false); const springApi = useSpringRef(); const spring = useSpring({ ref: springApi, from: { width: \u0026#34;100%\u0026#34;, height: \u0026#34;100%\u0026#34;, backgroundColor: `rgb(${Math.floor(Math.random() * 256)},${Math.floor( Math.random() * 256 )},${Math.floor(Math.random() * 256)})` }, to: { width: \u0026#34;20%\u0026#34;, height: \u0026#34;20%\u0026#34;, backgroundColor: \u0026#34;red\u0026#34; }, reverse: show }); const transApi = useSpringRef(); const trans = useTransition(show ? data : [], { ref: transApi, //动画开始前的延迟时间，以毫秒为单位 trail: 400 / data.length, from: { opacity: 0, scale: 0, backgroundColor: `yellow` }, enter: { opacity: 1, scale: 1 }, leave: { opacity: 0, scale: 0 } }); useChain(show ? [springApi, transApi] : [transApi, springApi], [0, 0.5]); return ( \u0026lt;div className=\u0026#34;wrapper\u0026#34;\u0026gt; \u0026lt;h2\u0026gt;四、useChain用法：用于自定义Spring执行顺序\u0026lt;/h2\u0026gt; \u0026lt;h3\u0026gt;将多个动画排队或链接在一起\u0026lt;/h3\u0026gt; \u0026lt;div className=\u0026#34;box\u0026#34; style={{ textAlign: \u0026#34;center\u0026#34; }}\u0026gt; \u0026lt;animated.div style={{ display: \u0026#34;flex\u0026#34;, alignItems: \u0026#34;center\u0026#34;, justifyContent: \u0026#34;space-around\u0026#34;, ...spring }} \u0026gt; {trans((style, item) =\u0026gt; { return ( \u0026lt;animated.div className=\u0026#34;sbox\u0026#34; style={{ ...style, background: item.css }} \u0026gt; {item.name} \u0026lt;/animated.div\u0026gt; ); })} \u0026lt;/animated.div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;button onClick={() =\u0026gt; setShow((v) =\u0026gt; !v)} className=\u0026#34;mybtn\u0026#34;\u0026gt; 切换 \u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ); }; 运行效果：\n默认配置config:弹簧属性 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 mass?:number default 1 //弹簧质量：回弹惯性，质量越大惯性越大 tension?:number default 170 //弹簧张力：影响整体速度，张力越紧速度越快。 friction?:number default 26 //摩擦力可以与mass、tension的效果相互抵消 delay?:number //动画开始的延迟 duration?:number default undefined | 0 ms //动画执行的时间间隔 velocity?:number default undefined | 0 ms //动画的执行速度 clamp?:boolean default false //动画弹簧越过边界时是否立刻结束动画 precision?:number default 0.01 //准确率 easing?:(t:number)=\u0026gt; number default false;//缓动移动函数，默认是线性的，可以换成其他的如d3-ease(动画运行轨迹函数) 官方内置弹簧配置： config.default { mass: 1, tension: 170, friction: 26 } config.gentle { mass: 1, tension: 120, friction: 14 } config.wobbly { mass: 1, tension: 180, friction: 12 } config.stiff { mass: 1, tension: 210, friction: 20 } config.slow { mass: 1, tension: 280, friction: 60 } config.molasses { mass: 1, tension: 280, friction: 120 } useSpring使用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 interface useSpringsProps { //动画的起始值 from?: object //动画的终点值 to?: object | key =\u0026gt; object | Array\u0026lt;object\u0026gt; // 动画开始的延迟时间 delay?: number | key =\u0026gt; number // 弹簧的基本属性(影响动画的速度、轨迹等) config?: SpringConfig | key =\u0026gt; SpringConfig // 是否重头开始重新执行动画，只有设置reset才能达到想要的过渡动画效果 ，v9版本默认为true reset?: boolean default false // 如果为真，from和to设置的值将会对换，该属性只能和reset一起使用才能达到预期效果 reverse?: boolean default false //是否循环,v9新增属性 loop?: boolean default false // 如果为真，则停止动画(直接跳转到结束状态) immediate?: boolean | key =\u0026gt; boolean // 如果为true，将跳过渲染组件，直接写入dom native?: boolean default false // 动画开始时执行 onStart?: (ds: DS) =\u0026gt; void // 所有动画都停止时执行 onRest?: (ds: DS) =\u0026gt; void } 插值使用 作用:在 react-spring 中，to 方法（插值）允许你根据一个动画值动态生成另一个值。这在创建复杂动画时非常有用，比如根据元素的高度动态改变其颜色。interpolate(v9interpolate替换为to)\n为什么需要插值? 动态绑定值：你可以根据一个动画值动态绑定另一个值，而不需要手动编写复杂的逻辑。 平滑过渡：插值确保值的变化是平滑的，而不是突变的，从而创建流畅的动画效果。 灵活性：你可以定义输入值的范围和对应的输出值，实现复杂的映射关系。 示例：假设你有一个 div，它的高度从 0px 动画到 100px，你希望在这个过程中，div 的背景颜色从红色变为绿色，再变为蓝色。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 import React from \u0026#39;react\u0026#39;; import { useSpring, animated } from \u0026#39;@react-spring/web\u0026#39;; const AnimatedDiv = () =\u0026gt; { // 定义动画 const spring = useSpring({ from: { height: 0 }, // 初始高度 to: { height: 100 }, // 最终高度 config: { duration: 2000 }, // 动画持续时间 }); return ( \u0026lt;animated.div style={{ width: \u0026#39;100px\u0026#39;, height: spring.height, // 动态绑定高度 backgroundColor: spring.height.to({ range: [0, 50, 100], // 输入范围 output: [\u0026#39;red\u0026#39;, \u0026#39;green\u0026#39;, \u0026#39;blue\u0026#39;], // 输出颜色 }), }} \u0026gt; Hello, World! \u0026lt;/animated.div\u0026gt; ); }; export default AnimatedDiv; 总结：通过使用 react-spring 的 to 方法（插值），你可以根据动画的每一帧的值动态地修改 div 的颜色或其他样式属性。这种技术不仅适用于高度，还可以用于宽度、透明度、位置等任何可以动画化的属性。这使得你可以创建非常复杂和动态的动画效果，而不需要手动编写复杂的逻辑。\nanimated组件 animated 组件本质上就是一个普通的 HTML 元素，但它被 react-spring 包装后，能够动态地应用动画值到它的样式上。你可以把它想象成一个普通的 HTML 元素，只是它能够“理解”动画值，并且能够根据这些值自动更新样式。\n示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 import React from \u0026#39;react\u0026#39;; import { useSpring, animated } from \u0026#39;@react-spring/web\u0026#39;; const AnimatedDiv = () =\u0026gt; { // 定义动画 const spring = useSpring({ from: { width: 0, backgroundColor: \u0026#39;red\u0026#39;, height: \u0026#39;50px\u0026#39; }, // 初始状态 to: { width: 100, backgroundColor: \u0026#39;blue\u0026#39;, height: \u0026#39;50px\u0026#39; }, // 最终状态 config: { duration: 2000 }, // 动画持续时间 }); return ( \u0026lt;animated.div style={spring} // 直接将 spring 对象绑定到 style 属性上 \u0026gt; Hello, World! \u0026lt;/animated.div\u0026gt; ); }; export default AnimatedDiv; useSprings使用 参数：第一个：需要创建的spring的个数，第二个：useSpringProps对象数组\n示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 const springs=useSprings(5,[ { from:{height:\u0026#39;40px\u0026#39;}, to:{height:\u0026#39;100px\u0026#39;,backgroundColor:\u0026#39;yellow\u0026#39;}, reverse:show, config:{ mass:1 } }, { from:{height:\u0026#39;40px\u0026#39;}, to:{height:\u0026#39;150px\u0026#39;,backgroundColor:\u0026#39;blue\u0026#39;}, reverse:show, config:{ mass:3 } } ]) useTrail使用 参数：第一个：需要创建spring的个数，第二个：useSpringProps(多个元素执行同一个动画)。\n示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 const springs=useTrail(6,[ { from:{height:\u0026#39;40px\u0026#39;}, to:{height:\u0026#39;100px\u0026#39;,backgroundColor: `rgb(${Math.floor(Math.random() * 256)},${Math.floor(Math.random() * 256)},${Math.floor(Math.random() * 256)})`}, reverse:show, config:{ mass:1 } }, { from:{height:\u0026#39;40px\u0026#39;}, to:{height:\u0026#39;150px\u0026#39;,backgroundColor: `rgb(${Math.floor(Math.random() * 256)},${Math.floor(Math.random() * 256)},${Math.floor(Math.random() * 256)})`}, reverse:show, config:{ mass:3 } } ]) useChain使用 用来控制不同的 spring 的执行顺序的，它没有返回值，接收一个springRef的数组，然后将数组的动画从左到右依次执行。 useTransition使用 用于实现组件 mounted/unmounted 等生命周期时的过渡效果动画，其他的 API 都不能对组件生命周期进行控制。\n示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 const springApi = useSpringRef() const spring = useSpring({ ref: springApi, from: { width: \u0026#39;100%\u0026#39;, height: \u0026#39;100%\u0026#39;, }, to: { width: \u0026#39;20%\u0026#39;, height: \u0026#39;20%\u0026#39;, backgroundColor: \u0026#39;red\u0026#39; }, reverse: show, }) const transApi = useSpringRef(); const trans = useTransition(show ? data : [], { ref: transApi, //动画开始前的延迟时间，以毫秒为单位 trail: 400 / data.length, from: { opacity: 0, scale: 0, backgroundColor: `yellow` }, enter: { opacity: 1, scale: 1 }, leave: { opacity: 0, scale: 0 } }); useChain([springApi, transApi]） {trans((style, item) =\u0026gt; { return ( \u0026lt;animated.div className=\u0026#34;sbox\u0026#34; style={{ ...style, background: item.css }} \u0026gt; {item.name} \u0026lt;/animated.div\u0026gt; ) })} const trans = useTransition(show ? data : [], {...} 导演要指挥谁？ 这取决于 show 这个开关。 如果 show 是 true（开关打开），导演就指挥 data 数组里的所有演员。 如果 show 是 false（开关关闭），导演就指挥一个空数组 []（也就是没有演员，所有人都要退场）。 ref: transApi, 给这位导演起个外号或者给他一个对讲机，叫 transApi。这样你之后就可以用这个对讲机（transApi）来直接给导演下命令，比如“开始！”或“停下！”。 trail: 400 / data.length, 演员上/下场的间隔时间。 为了让表演有节奏感，不是所有演员一窝蜂地冲上台。 400 毫秒是所有演员依次完成动作的总时间。 400 / data.length 的意思是：把总时间平均分给每一个演员。 例子： 如果有 4 个演员，那么每个演员的间隔就是 400 / 4 = 100 毫秒。第一个演员动作开始后，等100毫秒第二个开始，再等100毫秒第三个开始\u0026hellip;以此类推。这样就会形成一个连贯的、有顺序的动画效果。 from: { opacity: 0, scale: 0, backgroundColor: 'yellow' } 演员的“起始化妆和站位”（也就是动画开始前的状态）。 opacity: 0： 完全透明（看不见）。 scale: 0： 尺寸缩小到0（无限小，看不见）。 backgroundColor: 'yellow'： （虽然看不见）但背景色是黄色。这个通常在“进入”动画中会逐渐变回元素本身的颜色，所以这里可能看不到黄色，除非特意配置。 enter: { opacity: 1, scale: 1 } 当演员上台时（元素出现时） 要做的动作： 从完全透明（0）变成完全不透明（1）—— 慢慢显现出来。 从无限小（0）变成正常大小（1）—— 慢慢放大出来。 （它会从 from 的状态，变化到 enter 的状态） leave: { opacity: 0, scale: 0 } 当演员退场时（元素消失时） 要做的动作： 从当前状态变成完全透明（0）和无限小（0）—— 慢慢消失并缩小。 （它会从当前的状态，变化到 leave 的状态） ","date":"2025-09-09T16:34:41+08:00","image":"http://localhost:1313/img/tanhuang.jpg","permalink":"http://localhost:1313/p/react-spring%E7%BB%84%E4%BB%B6%E5%BA%93%E4%BB%8B%E7%BB%8D/","title":"React-Spring组件库介绍"},{"content":"handleScreenAuto 函数文档 目的 自适应调整数据大屏的显示，使其在不同分辨率的屏幕上保持设计稿的宽高比。\n函数逻辑 定义设计稿的宽度 (designDraftWidth) 和高度 (designDraftHeight)。 获取包含大屏元素 (#bigScreenV2) 的父元素 (documentElement)。 计算屏幕的宽高比与设计稿的宽高比，确定缩放比例 (scale)： 如果屏幕的宽高比小于设计稿的宽高比，则按宽度比例缩放。 否则，按高度比例缩放。 获取大屏元素 (dom) 并应用缩放和平移变换： 使用 transform 属性设置缩放和平移。 计算调整后的大屏元素的宽度和高度，并设置到地图组件的宽度和高度 (setMapWidthAndHeight)。 示例代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 const handleScreenAuto = () =\u0026gt; { const designDraftWidth = 1920; // 设计稿的宽度 const designDraftHeight = 1080; // 设计稿的高度 const documentElement = largeScreenV2Ref.current.parentElement; // 根据屏幕的变化适配的比例 const scale = documentElement.clientWidth / documentElement.clientHeight \u0026lt; designDraftWidth / designDraftHeight ? documentElement.clientWidth / designDraftWidth : documentElement.clientHeight / designDraftHeight; // 缩放比例 const dom = document.querySelector(\u0026#34;#bigScreenV2\u0026#34;) as any; dom.style.transform = `scale(${scale}) translate(-50%)`; // 尝试重置地球的缩放比例 const width = (dom.clientWidth * scale).toFixed(2); const height = (dom.clientHeight * scale).toFixed(2); setMapWidthAndHeight({ width, height, }); }; useEffect(() =\u0026gt; { if (largeScreenV2Ref.current) { //初始化自适应 ----在刚显示的时候就开始适配一次 handleScreenAuto(); //绑定自适应函数 ---防止浏览器栏变化后不再适配 window.onresize = () =\u0026gt; handleScreenAuto(); //退出大屏后自适应消失 ---这是react的组件销毁生命周期 } return () =\u0026gt; { window.onresize = null; }; }, [largeScreenV2Ref]); return ( \u0026lt;div className=\u0026#34;center-v2\u0026#34; ref={largeScreenV2Ref}\u0026gt; \u0026lt;div id=\u0026#34;bigScreenV2\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; ); 1 2 3 4 5 6 7 8 9 10 #bigScreenV2 { display: inline-block; width: 1920px; //设计稿的宽度 height: 1080px; //设计稿的高度 transform-origin: 0 0; position: absolute; pointer-events:none; left: 50%; z-index: 2; } 注意事项 确保 largeScreenV2Ref 引用的元素存在且已正确初始化。 该函数假设大屏元素 (#bigScreenV2) 是绝对定位的，并且其父元素是相对定位的。 该函数可能需要在窗口大小变化时调用，例如通过监听 window.resize 事件。 使用场景 当需要在不同分辨率的屏幕上保持数据大屏的布局和比例时。 当需要动态调整地图组件的大小以适应大屏元素的变化时。 ","date":"2025-09-08T16:50:59+08:00","permalink":"http://localhost:1313/p/%E5%A4%A7%E5%B1%8F%E8%87%AA%E9%80%82%E5%BA%94%E5%87%BD%E6%95%B0/","title":"大屏自适应函数"},{"content":" width: fit-content;设置元素的宽度刚好能够容纳其内容; box-sizing: border-box;定义元素的盒模型（box model）的计算方式。它的作用是让元素的宽度和高度包括内容、内边距（padding）和边框（border），但不包括外边距（margin）。这与默认的盒模型（\u0026lt;font style=\u0026quot;color:#D22D8D;background-color:rgba(0, 0, 0, 0.03);\u0026quot;\u0026gt;content-box\u0026lt;/font\u0026gt;）不同，在默认的盒模型中，宽度和高度只包括内容，不包括内边距和边框。 aspect-ratio: 4 / 3;用于保证元素的宽高比例不变； pointer-events; auto:元素会按照正常的文档流顺序来响应鼠标事件。如果元素可见并且没有被其他元素遮挡，那么它就可以成为鼠标事件的目标。 none:当设置为 none 时，元素不会响应任何鼠标事件，即使鼠标悬停在元素上或点击元素。这相当于元素对于鼠标事件是“透明”的。然而，值得注意的是，none 值不会影响元素的子元素。如果子元素没有设置 pointer-events 属性，或者显式设置为 auto，那么子元素仍然可以响应鼠标事件。 visiblePainted：元素只有当它是可见的（即，它有内容，并且没有被 visibility 属性设置为 hidden）并且被绘制到屏幕上时，才会响应鼠标事件。 visibleFill：元素只有在它是可见的，并且被绘制为一个填充区域（例如，背景颜色或图片）时，才会响应鼠标事件。 visibleStroke：元素只有在它是可见的，并且被绘制为一个轮廓（例如，边框）时，才会响应鼠标事件。 visible:元素只有在它是可见的时，才会响应鼠标事件。这包括了 visiblePainted、visibleFill 和 visibleStroke 的所有情况。 painted:元素只有在它被绘制到屏幕上时，才会响应鼠标事件，无论它是否可见。 fill:元素只有在它被绘制为一个填充区域时，才会响应鼠标事件。 stroke:元素只有在它被绘制为一个轮廓时，才会响应鼠标事件。 使用场景： auto:适用于普通元素，你希望它们能够正常响应鼠标事件。 none:当你希望元素本身不响应鼠标事件，但允许事件穿透到下面的元素时。这在制作覆盖层或者需要鼠标事件穿透的场景中非常有用。 visiblePainted、visibleFill、visibleStroke:这些值通常用于更精细的控制，例如，你可能希望一个元素只有在它有背景颜色时才响应鼠标事件。 ","date":"2025-09-08T16:39:21+08:00","permalink":"http://localhost:1313/p/%E5%A4%A7%E5%B1%8F%E4%B8%AD%E4%B8%80%E4%BA%9B%E5%B8%B8%E7%94%A8%E7%9A%84css%E5%B1%9E%E6%80%A7/","title":"大屏中一些常用的css属性"},{"content":"leaflet格网的作用：希望格网的间距与地图的缩放层级相关联，并且格网的大小应该类似于地图瓦片的分辨率。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Leaflet 动态格网示例\u0026lt;/title\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://unpkg.com/leaflet/dist/leaflet.css\u0026#34; /\u0026gt; \u0026lt;style\u0026gt; #map { height: 100vh; width: 100%; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;map\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script src=\u0026#34;https://unpkg.com/leaflet/dist/leaflet.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; // 初始化地图 var map = L.map(\u0026#39;map\u0026#39;, { center: [39.9042, 116.4074], // 以北京为例 zoom: 13, minZoom: 5, maxZoom: 18 }); // 添加默认瓦片图层 L.tileLayer(\u0026#39;https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png\u0026#39;, { attribution: \u0026#39;Map data \u0026amp;copy; \u0026lt;a href=\u0026#34;https://www.openstreetmap.org/copyright\u0026#34;\u0026gt;OpenStreetMap\u0026lt;/a\u0026gt; contributors\u0026#39; }).addTo(map); // 动态绘制格网 function drawGrid() { // 获取当前地图层级 const currentZoom = map.getZoom() // 清除旧的格网 map.eachLayer(function (layer) { if (layer instanceof L.Polyline) { map.removeLayer(layer); } }); if (currentZoom \u0026gt;= 15) { return } var zoom = map.getZoom(); var bounds = map.getBounds(); // 计算当前缩放层级下的分辨率 var resolution = 180 / Math.pow(2, zoom); // 计算格网的起始点 var minLat = Math.floor(bounds.getSouth() / resolution) * resolution; var maxLat = Math.ceil(bounds.getNorth() / resolution) * resolution; var minLng = Math.floor(bounds.getWest() / resolution) * resolution; var maxLng = Math.ceil(bounds.getEast() / resolution) * resolution; // 经度格网 for (var lng = minLng; lng \u0026lt;= maxLng; lng += resolution) { L.polyline([ [minLat, lng], [maxLat, lng] ], { color: \u0026#39;blue\u0026#39;, weight: 1 }).addTo(map); } // 纬度格网 for (var lat = minLat; lat \u0026lt;= maxLat; lat += resolution) { L.polyline([ [lat, minLng], [lat, maxLng] ], { color: \u0026#39;blue\u0026#39;, weight: 1 }).addTo(map); } } // 初始化格网 drawGrid(); // 监听地图缩放事件，动态更新格网 map.on(\u0026#39;zoomend\u0026#39;, drawGrid); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; ","date":"2025-09-08T13:35:07+08:00","permalink":"http://localhost:1313/p/leaflet%E6%B7%BB%E5%8A%A0%E6%A0%BC%E7%BD%91demo/","title":"leaflet添加格网demo"},{"content":"React的渲染机制基于虚拟dom的概念。虚拟dom是真实dom的js对象的表示，React通过比较虚拟DOM的变化来高效的真实更新DOM,从而减少不必要的DOM操作，用于提高性能。\n类组件的生命周期：\n构造函数(constructor)：初始化组件的状态和绑定事件处理函数（组件实例化时调用一次） 1 2 3 4 5 6 class MyComponent extends React.Component { constructor(props) { super(props); this.state = { count: 0 }; } } 组件挂载(componentDidMount):组件挂载后调用一次： 1 2 3 4 5 componentDidMount() { fetch(\u0026#39;https://api.example.com/data\u0026#39;) .then(response =\u0026gt; response.json()) .then(data =\u0026gt; this.setState({ data })); } 组件更新: shouldComponentUpdate:决定组件是否需要重新渲染，可以避免不必要的渲染；组件接受到新的props和state时调用。 1 2 3 shouldComponentUpdate(nextProps, nextState) { return nextState.count !== this.state.count; } getSnapshotBeforeUpdate:在组件更新之前捕获DOM的状态，例如滚动位置等。返回一个值，该值将作为componentDidUpdate的第三个参数。 1 2 3 4 5 6 getSnapshotBeforeUpdate(prevProps, prevState) { if (prevProps.data !== this.props.data) { return this.someRef.current.scrollTop; } return null; } componentDidUpdate:组件更新完成后调用（主要用于更新DOM） 1 2 3 4 5 componentDidUpdate(prevProps, prevState, snapshot) { if (snapshot !== null) { this.someRef.current.scrollTop = snapshot; } } 组件卸载(componentWillUnmount)：组件卸载时调用（清理资源、取消订阅、清理定时器等） 1 2 3 componentWillUnmount() { clearInterval(this.timer); } 函数组件生命周期：\nuseState: useEffect: useLayoutEffect:会在所有DOM变更之后同步调用，可以用于读取DOM布局并同步重新渲染 useMemo:用于缓存计算值，避免不必要的计算。 useCallback:用于缓存函数，避免不必要的函数重新创建 useRef:创建一个可变的引用，其值在组件的整个生命周期内保持不变 useImperativeHandle:用于自定义暴露给父组件的实例值 useReducer: useContext: ","date":"2025-09-08T13:17:13+08:00","permalink":"http://localhost:1313/p/react%E7%B1%BB%E7%BB%84%E4%BB%B6%E5%92%8C%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6%E7%9A%84%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6%E4%BB%A5%E5%8F%8A%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0/","title":"react类组件和函数组件的渲染机制以及钩子函数"},{"content":"在 Web 地图开发中，瓦片（Tile）是地图数据的基本单位。不同坐标系（如 EPSG:3857 和 EPSG:4326）的瓦片边界计算方式不同，直接影响地图渲染和数据查询的准确性。本文档详细说明两种坐标系下的瓦片边界计算方法，并提供代码实现。\n坐标系简介：\n坐标系 名称 单位 适用范围 特点 EPSG:3857 Web 墨卡托 米（meters） Google Maps、OpenStreetMap 适用于 Web 地图，高纬度地区变形严重 EPSG:4326 WGS84 经纬度 度（degrees） 传统 GIS 系统 直接使用经纬度，无投影变形 瓦片边界计算：\nEPSG:4326(WGS84经纬度)\nEPSG:3857(Web墨卡托)获取瓦片的蜜汁坐标范围转换为经纬度 EPSG:3857(Web墨卡托)获取瓦片的蜜汁坐标范围转换为经纬度 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 tileLatLonBounds(x,y,zoom){ const map=L.map(\u0026#39;map\u0026#39;,{ // 使用4326坐标系 } const tilesize=256; const nwPoint=L.point(x*tileSize,(y+1)*tileSize); const sePoint=L.point((x+1)*tilesize,y*tilesize); const nw=map.unproject(nwPoint,zoom) const se=map.unproject(sePoint,zoom); return { x1:nw.lng; y1:nw.lat; x2:se.lng; y2:se.lat; } } EPSG:3857(web墨卡托)\n获取瓦片的坐标范围 转换为经纬度 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 pixelsToMeters2(x, y, zoom) { let res = this.resolution(zoom); let mx = x * res - (2 * Math.PI * 6378137) / 2.0; let my = y * res - (2 * Math.PI * 6378137) / 2.0; return { x: mx, y: Math.abs(my) }; } tileBounds(x, y, zoom) { let minPoints = this.pixelsToMeters2(x * 256, y * 256, zoom); let maxPoints = this.pixelsToMeters2((x + 1) * 256, (y + 1) * 256, zoom); return { x1: minPoints.x, x2: maxPoints.x, y1: maxPoints.y, y2: minPoints.y, }; } MetersToLatLon(x, y) { let lon = (x / ((2 * Math.PI * 6378137) / 2.0)) * 180.0; let lat = (y / ((2 * Math.PI * 6378137) / 2.0)) * 180.0; lat = (180 / Math.PI) * (2 * Math.atan(Math.exp((lat * Math.PI) / 180.0)) - Math.PI / 2.0); return { lat: lat, lon: lon }; } tileLatLonBounds(x, y, zoom) { let crs = MapContent._crs; let envelope = this.tileBounds(x, y, zoom); let minLatLon = this.MetersToLatLon(envelope.x1, envelope.y1); let maxLatLon = this.MetersToLatLon(envelope.x2, envelope.y2); return { x1: minLatLon.lon, x2: maxLatLon.lon, y1: minLatLon.lat, y2: maxLatLon.lat, }; } ","date":"2025-09-08T10:18:14+08:00","permalink":"http://localhost:1313/p/leaflet%E4%B8%8D%E5%90%8C%E5%9D%90%E6%A0%87%E7%B3%BB%E4%B8%8B%E7%93%A6%E7%89%87%E8%BE%B9%E7%95%8C%E8%AE%A1%E7%AE%97%E6%96%B9%E6%B3%95/","title":"leaflet不同坐标系下，瓦片边界计算方法"},{"content":"数组转对象时的顺序问题 数组转对象的常见方式： 1 2 3 4 5 6 7 8 9 10 11 const arr = [ { id: 3, name: \u0026#39;Tom\u0026#39; }, { id: 1, name: \u0026#39;Jerry\u0026#39; }, { id: 2, name: \u0026#39;Spike\u0026#39; } ]; // 方式一：普通对象（数字或数字字符串作为 key） const obj = {}; arr.forEach(item =\u0026gt; { obj[item.id] = item; }); 遭遇的问题： 当对象的 key 是数字或类似数字的字符串（如 \u0026lt;font style=\u0026quot;color:rgba(0, 0, 0, 0.9);background-color:rgba(0, 0, 0, 0.03);\u0026quot;\u0026gt;'1'\u0026lt;/font\u0026gt;, \u0026lt;font style=\u0026quot;color:rgba(0, 0, 0, 0.9);background-color:rgba(0, 0, 0, 0.03);\u0026quot;\u0026gt;'2'\u0026lt;/font\u0026gt;, \u0026lt;font style=\u0026quot;color:rgba(0, 0, 0, 0.9);background-color:rgba(0, 0, 0, 0.03);\u0026quot;\u0026gt;'3'\u0026lt;/font\u0026gt;）时，JavaScript 引擎会自动按照数字升序排列这些 key。 因此，转换后的对象属性顺序无法保证与原始数组顺序一致。 解决方案：使用map数据结构 1 2 3 4 5 6 7 8 const map = new Map(); arr.forEach(item =\u0026gt; { map.set(item.id, item); }); // 遍历 Map，顺序与数组一致 map.forEach((value, key) =\u0026gt; { console.log(key, value); }); Map 是 ES6 引入的数据结构，专门用于保存键值对。 Map 会严格记住键的插入顺序，遍历时会按照插入顺序返回键值对。 ","date":"2025-09-08T10:12:49+08:00","permalink":"http://localhost:1313/p/%E6%9C%80%E8%BF%91%E9%81%87%E5%88%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E6%9C%89%E5%85%B3%E5%AF%B9%E8%B1%A1%E7%9A%84%E9%97%AE%E9%A2%98/","title":"最近遇到的一些有关对象的问题"}]