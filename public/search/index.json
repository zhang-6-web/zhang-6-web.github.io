[{"content":"leaflet格网的作用：希望格网的间距与地图的缩放层级相关联，并且格网的大小应该类似于地图瓦片的分辨率。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Leaflet 动态格网示例\u0026lt;/title\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://unpkg.com/leaflet/dist/leaflet.css\u0026#34; /\u0026gt; \u0026lt;style\u0026gt; #map { height: 100vh; width: 100%; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;map\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script src=\u0026#34;https://unpkg.com/leaflet/dist/leaflet.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; // 初始化地图 var map = L.map(\u0026#39;map\u0026#39;, { center: [39.9042, 116.4074], // 以北京为例 zoom: 13, minZoom: 5, maxZoom: 18 }); // 添加默认瓦片图层 L.tileLayer(\u0026#39;https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png\u0026#39;, { attribution: \u0026#39;Map data \u0026amp;copy; \u0026lt;a href=\u0026#34;https://www.openstreetmap.org/copyright\u0026#34;\u0026gt;OpenStreetMap\u0026lt;/a\u0026gt; contributors\u0026#39; }).addTo(map); // 动态绘制格网 function drawGrid() { // 获取当前地图层级 const currentZoom = map.getZoom() // 清除旧的格网 map.eachLayer(function (layer) { if (layer instanceof L.Polyline) { map.removeLayer(layer); } }); if (currentZoom \u0026gt;= 15) { return } var zoom = map.getZoom(); var bounds = map.getBounds(); // 计算当前缩放层级下的分辨率 var resolution = 180 / Math.pow(2, zoom); // 计算格网的起始点 var minLat = Math.floor(bounds.getSouth() / resolution) * resolution; var maxLat = Math.ceil(bounds.getNorth() / resolution) * resolution; var minLng = Math.floor(bounds.getWest() / resolution) * resolution; var maxLng = Math.ceil(bounds.getEast() / resolution) * resolution; // 经度格网 for (var lng = minLng; lng \u0026lt;= maxLng; lng += resolution) { L.polyline([ [minLat, lng], [maxLat, lng] ], { color: \u0026#39;blue\u0026#39;, weight: 1 }).addTo(map); } // 纬度格网 for (var lat = minLat; lat \u0026lt;= maxLat; lat += resolution) { L.polyline([ [lat, minLng], [lat, maxLng] ], { color: \u0026#39;blue\u0026#39;, weight: 1 }).addTo(map); } } // 初始化格网 drawGrid(); // 监听地图缩放事件，动态更新格网 map.on(\u0026#39;zoomend\u0026#39;, drawGrid); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; ","date":"2025-09-08T13:35:07+08:00","permalink":"http://localhost:1313/p/leaflet%E6%B7%BB%E5%8A%A0%E6%A0%BC%E7%BD%91demo/","title":"leaflet添加格网demo"},{"content":"React的渲染机制基于虚拟dom的概念。虚拟dom是真实dom的js对象的表示，React通过比较虚拟DOM的变化来高效的真实更新DOM,从而减少不必要的DOM操作，用于提高性能。\n类组件的生命周期：\n构造函数(constructor)：初始化组件的状态和绑定事件处理函数（组件实例化时调用一次） 1 2 3 4 5 6 class MyComponent extends React.Component { constructor(props) { super(props); this.state = { count: 0 }; } } 组件挂载(componentDidMount):组件挂载后调用一次： 1 2 3 4 5 componentDidMount() { fetch(\u0026#39;https://api.example.com/data\u0026#39;) .then(response =\u0026gt; response.json()) .then(data =\u0026gt; this.setState({ data })); } 组件更新: shouldComponentUpdate:决定组件是否需要重新渲染，可以避免不必要的渲染；组件接受到新的props和state时调用。 1 2 3 shouldComponentUpdate(nextProps, nextState) { return nextState.count !== this.state.count; } getSnapshotBeforeUpdate:在组件更新之前捕获DOM的状态，例如滚动位置等。返回一个值，该值将作为componentDidUpdate的第三个参数。 1 2 3 4 5 6 getSnapshotBeforeUpdate(prevProps, prevState) { if (prevProps.data !== this.props.data) { return this.someRef.current.scrollTop; } return null; } componentDidUpdate:组件更新完成后调用（主要用于更新DOM） 1 2 3 4 5 componentDidUpdate(prevProps, prevState, snapshot) { if (snapshot !== null) { this.someRef.current.scrollTop = snapshot; } } 组件卸载(componentWillUnmount)：组件卸载时调用（清理资源、取消订阅、清理定时器等） 1 2 3 componentWillUnmount() { clearInterval(this.timer); } 函数组件生命周期：\nuseState: useEffect: useLayoutEffect:会在所有DOM变更之后同步调用，可以用于读取DOM布局并同步重新渲染 useMemo:用于缓存计算值，避免不必要的计算。 useCallback:用于缓存函数，避免不必要的函数重新创建 useRef:创建一个可变的引用，其值在组件的整个生命周期内保持不变 useImperativeHandle:用于自定义暴露给父组件的实例值 useReducer: useContext: ","date":"2025-09-08T13:17:13+08:00","permalink":"http://localhost:1313/p/react%E7%B1%BB%E7%BB%84%E4%BB%B6%E5%92%8C%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6%E7%9A%84%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6%E4%BB%A5%E5%8F%8A%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0/","title":"react类组件和函数组件的渲染机制以及钩子函数"},{"content":"在 Web 地图开发中，瓦片（Tile）是地图数据的基本单位。不同坐标系（如 EPSG:3857 和 EPSG:4326）的瓦片边界计算方式不同，直接影响地图渲染和数据查询的准确性。本文档详细说明两种坐标系下的瓦片边界计算方法，并提供代码实现。\n坐标系简介：\n坐标系 名称 单位 适用范围 特点 EPSG:3857 Web 墨卡托 米（meters） Google Maps、OpenStreetMap 适用于 Web 地图，高纬度地区变形严重 EPSG:4326 WGS84 经纬度 度（degrees） 传统 GIS 系统 直接使用经纬度，无投影变形 瓦片边界计算：\nEPSG:4326(WGS84经纬度)\nEPSG:3857(Web墨卡托)获取瓦片的蜜汁坐标范围转换为经纬度 EPSG:3857(Web墨卡托)获取瓦片的蜜汁坐标范围转换为经纬度 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 tileLatLonBounds(x,y,zoom){ const map=L.map(\u0026#39;map\u0026#39;,{ // 使用4326坐标系 } const tilesize=256; const nwPoint=L.point(x*tileSize,(y+1)*tileSize); const sePoint=L.point((x+1)*tilesize,y*tilesize); const nw=map.unproject(nwPoint,zoom) const se=map.unproject(sePoint,zoom); return { x1:nw.lng; y1:nw.lat; x2:se.lng; y2:se.lat; } } EPSG:3857(web墨卡托)\n获取瓦片的坐标范围 转换为经纬度 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 pixelsToMeters2(x, y, zoom) { let res = this.resolution(zoom); let mx = x * res - (2 * Math.PI * 6378137) / 2.0; let my = y * res - (2 * Math.PI * 6378137) / 2.0; return { x: mx, y: Math.abs(my) }; } tileBounds(x, y, zoom) { let minPoints = this.pixelsToMeters2(x * 256, y * 256, zoom); let maxPoints = this.pixelsToMeters2((x + 1) * 256, (y + 1) * 256, zoom); return { x1: minPoints.x, x2: maxPoints.x, y1: maxPoints.y, y2: minPoints.y, }; } MetersToLatLon(x, y) { let lon = (x / ((2 * Math.PI * 6378137) / 2.0)) * 180.0; let lat = (y / ((2 * Math.PI * 6378137) / 2.0)) * 180.0; lat = (180 / Math.PI) * (2 * Math.atan(Math.exp((lat * Math.PI) / 180.0)) - Math.PI / 2.0); return { lat: lat, lon: lon }; } tileLatLonBounds(x, y, zoom) { let crs = MapContent._crs; let envelope = this.tileBounds(x, y, zoom); let minLatLon = this.MetersToLatLon(envelope.x1, envelope.y1); let maxLatLon = this.MetersToLatLon(envelope.x2, envelope.y2); return { x1: minLatLon.lon, x2: maxLatLon.lon, y1: minLatLon.lat, y2: maxLatLon.lat, }; } ","date":"2025-09-08T10:18:14+08:00","permalink":"http://localhost:1313/p/leaflet%E4%B8%8D%E5%90%8C%E5%9D%90%E6%A0%87%E7%B3%BB%E4%B8%8B%E7%93%A6%E7%89%87%E8%BE%B9%E7%95%8C%E8%AE%A1%E7%AE%97%E6%96%B9%E6%B3%95/","title":"leaflet不同坐标系下，瓦片边界计算方法"},{"content":"数组转对象时的顺序问题 数组转对象的常见方式： 1 2 3 4 5 6 7 8 9 10 11 const arr = [ { id: 3, name: \u0026#39;Tom\u0026#39; }, { id: 1, name: \u0026#39;Jerry\u0026#39; }, { id: 2, name: \u0026#39;Spike\u0026#39; } ]; // 方式一：普通对象（数字或数字字符串作为 key） const obj = {}; arr.forEach(item =\u0026gt; { obj[item.id] = item; }); 遭遇的问题： 当对象的 key 是数字或类似数字的字符串（如 \u0026lt;font style=\u0026quot;color:rgba(0, 0, 0, 0.9);background-color:rgba(0, 0, 0, 0.03);\u0026quot;\u0026gt;'1'\u0026lt;/font\u0026gt;, \u0026lt;font style=\u0026quot;color:rgba(0, 0, 0, 0.9);background-color:rgba(0, 0, 0, 0.03);\u0026quot;\u0026gt;'2'\u0026lt;/font\u0026gt;, \u0026lt;font style=\u0026quot;color:rgba(0, 0, 0, 0.9);background-color:rgba(0, 0, 0, 0.03);\u0026quot;\u0026gt;'3'\u0026lt;/font\u0026gt;）时，JavaScript 引擎会自动按照数字升序排列这些 key。 因此，转换后的对象属性顺序无法保证与原始数组顺序一致。 解决方案：使用map数据结构 1 2 3 4 5 6 7 8 const map = new Map(); arr.forEach(item =\u0026gt; { map.set(item.id, item); }); // 遍历 Map，顺序与数组一致 map.forEach((value, key) =\u0026gt; { console.log(key, value); }); Map 是 ES6 引入的数据结构，专门用于保存键值对。 Map 会严格记住键的插入顺序，遍历时会按照插入顺序返回键值对。 ","date":"2025-09-08T10:12:49+08:00","permalink":"http://localhost:1313/p/%E6%9C%80%E8%BF%91%E9%81%87%E5%88%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E6%9C%89%E5%85%B3%E5%AF%B9%E8%B1%A1%E7%9A%84%E9%97%AE%E9%A2%98/","title":"最近遇到的一些有关对象的问题"}]